---
title: 如何减少页面白屏的时间
nav:
  title: 性能优化
  path: /performance
  order: 0
group:
  title: 前端性能优化相关试题
  path: /performance/project
---

# 如何减少页面白屏的时间

- 2022.01.04

![请添加图片描述](https://img-blog.csdnimg.cn/f85fe12deaf54b76a01d94487651a2a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGpsMjcxMzE0,size_20,color_FFFFFF,t_70,g_se,x_16)

## FP 与 FCP

- FP(First Paint 文档中任意元素首次渲染时间，首屏时间): 我们可以在控制台输入`window.performance.getEntriesByType('paint')取第一个pain的时间`来获取首屏渲染时间。

注意：FP 不包含默认背景绘制，但包含非默认的背景绘制。

- FCP(First Contentful Paint 第一次有内容的渲染，白屏时间)，代表浏览器第一次向屏幕绘制 “内容”。

注意：只有首次绘制文本、图片（包含背景图）、非白色的 canvas 或 SVG 时才被算作 FCP。

通过`performance.getEntriesByType('paint’)`，取第二个`pain`的时间，或者通过`Mutation Observer`观察到首次节点变动的时间。

### 主要区别

`FP`与`FCP`这两个指标之间的主要区别是：

- FP 是当浏览器开始绘制内容到屏幕上的时候，只要在视觉上开始发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做 FP。

- 相比之下，FCP 指的是浏览器首次绘制来自 DOM 的内容。例如：文本，图片，SVG，canvas 元素等，这个时间点叫 FCP。

FP 和 FCP 可能是相同的时间，也可能是先 FP 后 FCP。

## FMP

`First Meaningful Paint`是页面主要内容出现在屏幕上的时间，这将是用户感知加载体验的主要指标。

目前尚无标准化的定义，因为很难以通用的方式去确定各种类型页面的关键内容。实践中，可以将页面评分最高的可见内容出现在屏幕上的时间作为 `First Meaningful Paint`。

### 统计逻辑

`Mutation Observer`将会观察页面加载的前 30S 内页面节点的变化, 将新增/移除的节点加入/移除`Intersection Observer`, 这样可以得到页面元素的可见时间点及元素与可视区域的交叉信息。

根据元素的类型进行权重取值, 然后取元素与可视区域的交叉区域面积、可见度、 权重值之间的乘积为元素评分。

根据上面得到的信息, 以时间点为 X 轴, 该时间点可见元素的评分总和为 Y 轴, 取最高点对应的最小时间为页面主要内容出现在屏幕上的时间。

[参考文章](https://zhuanlan.zhihu.com/p/44933789)

## TTI

全称`Time to Interactive`，翻译为“可交互时间”，表示网页`第一次完全达到可交互状态`的时间点。

可交互状态指的是页面上的 UI 组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过 50 毫秒。TTI 很重要，因为 TTI 可以让我们了解我们的产品需要多久可以真正达到“可用”的状态。

## 性能优化

### 1. DNS 解析优化

在开始策略之前，我们需要补充下列知识。

#### IP 地址和域名

- IP 地址

互联网协议地址（Internet Protocol Address），是 IP 协议提供的统一地址格式。

计算机之间想要实现相互通信，就必须要有唯一的网络地址标识，即 IP 地址；每台连网计算机都依靠 IP 地址来互相区分、相互联系。

- 域名

域名和 IP 地址一样都是用来做网络地址标识的，相对于 IP 来说域名更便于用户记忆。

- 域名和 IP 地址的关系

在互联网上，域名和 IP 地址之间是`一对一`或`多对一`的关系，也就是说一个 IP 地址可以对应多个域名，但一个域名只能有一个 IP 地址。

- 总结

  - IP 地址是面向网络的，而域名则是面向用户的。
  - 计算机之间网络通信只认 IP 地址，所以域名和 IP 地址之间的转换工作被称之为`域名解析`。
  - 域名解析由专门的域名解析服务器来完成，即 DNS 服务器。

#### DNS 域名解析过程

- **第 1 步，查找浏览器缓存。**

  浏览器会检查缓存中有没有这个域名对应的解析过的 IP 地址，如果缓存中有，这个解析过程就将结束。

  浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等(通过 TTL 属性来设置，默认情况下 Chrome 会缓存 1 分钟的 DNS 查找。)。

  这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的 IP 有变化，会导致被客户端缓存的域名无法解析到变化后的 IP 地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。

  **实际情况下尽管操作系统缓存会考虑 `TTL` 值，但浏览器通常忽略该值，并设置它自己的时间限制。**

  [浏览器查看和清除 DNS 缓存](https://www.cnblogs.com/shengulong/p/7443806.html)

  清除系统的 DNS 缓存：

  - window:

    ```js
    // 查看
    ipconfig / displaydns;

    // 清除
    ipconfig / flushdns;
    ```

  - macOS:

    ```js
    sudo killall -HUP mDNSResponder
    ```

- **第 2 步，查找系统(hosts)缓存。**

  如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的 DNS 解析结果。

  操作系统也会有一个域名解析的过程，例如在`Windows`中可以通过`C:\Windows\System32\drivers\etc\hosts`文件来设置。我们可以将任何域名解析到任何能够访问的 IP 地址。

  假如我们在这里指定了一个域名对应的 IP 地址，那么浏览器会首先使用这个 IP 地址。

  例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。

  也正是因为有这种本地 DNS 解析的规程，所以黑客就有可能通过修改你的域名解析来把特定的域名解析到它指定的 IP 地址上，导致这些域名被劫持。

  [macOS 修改 hosts 文件](https://jingyan.baidu.com/article/f3ad7d0f55154309c3345bdd.html)
  [windows 修改 hosts 文件](https://jingyan.baidu.com/article/9113f81b49ed2f2b3214c7fa.html)

- **第 3 步，查找路由器缓存。**

  如果系统缓存中也找不到，那么查询请求就会发向路由器，它一般会有自己的 DNS 缓存。

- **第 4 步，查找 ISP DNS 缓存。**

  如果本地 hosts 文件不存在映射关系，则查找本地 DNS 服务器(ISP 服务器,或者自己手动设置的 DNS 服务器)。

  在我们的网络配置中都会有"DNS 服务器地址"这一项，操作系统会把这个域名发送给这里设置的 DNS，也就是本地区的域名服务器（LDNS），通常由互联网服务提供商（ISP）提供，比如电信或者联通。

  这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约 80%的域名解析都到这里就已经完成了，所以 ISP DNS 主要承担了域名的解析工作。

- **第 5 步，迭代查询。**

  如果本地 DNS 服务器还没找到的话,它就会向根服务器(实际上`www.baidu.com` 的完整写法是 `www.baidu.com.`，最后的这个 `.` 就是根域名，只是这个点我们一般都不写)发出请求,进行递归查询。

  根域名服务器将所要查询域名中的顶级域名（假设要查询`www.baidu.com`，该域名的顶级域就是`com`）的服务器 IP 地址返回到本地 DNS。

  本地 DNS 根据返回的 IP 地址，再向顶级域（就是 com 域）发送请求。

  `com域服务器`再将域名中的二级域（即`www.baidu.com`中的`baidu`）的 IP 地址返回给本地 DNS。

  本地 DNS 再向二级域发送请求进行查询。

  之后不断重复这样的过程，直到本地 DNS 服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。

#### 针对`DNS Lookup`环节，我们可以针对性的进行 DNS 解析优化

- DNS 缓存优化
  - 使用浏览器 DNS 缓存 、计算机 DNS 缓存、 服务器 DNS 缓存，防止 DNS 迭代查询；
  - `HTTP`协议中的`Keep-Alive`特性可以同时覆盖 TTL 和浏览器的时间限制。通过设置`Keep-Alive`，一个持久的 TCP 连接将会一直使用，直到其空闲`1`分钟为止，由于连接是持久的，`Keep-Alive`通过重用现有的连接，避免了`DNS`查找；
  - 使用较少的域名（服务器主机）来减少 DNS 查找的数量。
- DNS 预加载策略(DNS Prefetch)

  - 通过用`meta`信息来告知浏览器, 我这页面要做 DNS 预解析

    ```html
    <meta http-equiv="x-dns-prefetch-control" content="on" />
    ```

    通过设置响应头的方式

    ```js
    ctx.set('X-DNS-Prefetch-Control', 'on');
    ```

  - 通过使用`link`标签来强制对 DNS 做预解析:

    ```html
    <link rel="dns-prefetch" href="https://fonts.com" />
    ```

    - `DNS-prefetch`仅对`跨域`的 DNS 查找有效。
    - `dns-prefetch`要谨慎使用，多页面重复 DNS 预解析会增加 DNS 查询次数。
    - 默认情况下浏览器会对页面中和当前域名不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行获取，那么就要使用显示的`DNS Prefetch了`。

- 稳定可靠的 DNS 服务器

### 2.TCP 网络链路优化

- 服务器配置调优
  - 增大 TCP 的初始拥塞窗口
  - 慢启动重启
  - 窗口缩放（RFC 1323）
  - TCP 快速打开

剩余从代码、资源等场景描述，参考[前端性能优化](/performance/project/front)
