---
title: 盒马前端专家面试
nav:
  title: 模拟试题
  path: /demos
  order: 0
group:
  title: 技术部分
  path: /demos/technology
---

# 盒马前端专家面试

## 1.先做个自我介绍把？

面试官你好，我叫许将龙，今年 28 岁，浙江台州人，计算机相关专业毕业，从事前端相关的工作已经有 6 年。

自工作以来，主要深耕于 PC、H5、公众号、小程序、Hybrid 等方向，业务范围主要囊括了电商、金融、直播、拍卖行等场景，技术栈方面个人擅长以 React 为主的相关技术栈。

之前担任公司业务线内前端团队的 Leader，负责主站核心业务--直播和拍卖行相关的业务开发、团队资源统筹、项目管理以及成员带教相关的工作。期间也带领团队完成了多次核心业务指标贡献，辅导了 4 位成员的转正和晋升工作。

此外我也是一个擅长总结和归纳的人，除了定期在团队内外组件技术分享外，闲暇的时间我也沉淀了上百篇的技术博客。

最后，我是一个外向、乐观、自律的人，擅长与人沟通，学习能力强，能够快速的融入到团队中来。

## 2.之前有用 node 做过什么项目呢？

之前一些内部的系统以及个人的一些项目有完整的去用过 node。

## 3. 之前用的是什么框架？

主要用的是 Koa2。

## 4. express 有用过么？express 和 koa2 有什么区别？

1. 体积上：Koa2 不涉及路由以及其他中间件的捆绑，体积比 Express 小;
2. 写法：Koa2 使用 async 函数 ，Express 使用 Promise 回调 ，因此 Koa2 可以避免回调，而且可以使用 try catch 更方便地去处理错误异常;
3. 中间件机制：

- Koa2 使用 洋葱圈模式 ，其核心实现思想是使用函数调用栈，先调用的后执行，直到里层函数一层一层由里向外执行完。
- Express 核心思想是使用任务队列，先进队列的先取出执行，后面的任务进队等待，直到前面的任务都执行完后再执行。

优势：

- 对于结果获取：Express 通过 Promise 的 resolve 的回调，获取 resolve 得到的结果；而 Koa2 通过 await 一个 async 函数，使用同步的写法实现异步的效果，写法更清晰。

- 对于错误捕捉：Express 对于每个 callback 都要做错误捕捉，然后一层一层向外传递；而 Koa2 可以使用一个 try catch 就可以实现所有错误的捕捉。

## 5. egg 有去了解过么 和 koa2 有什么区别？

egg 有做过一定的了解和学习。

总的来说，egg 本身也是基于 koa2 的思想去设计，主要是一种面向企业级的解决方案。

解决了 koa2 的一些问题，比如因为本来 koa2 不提供视图模板、路由、日志等各种功能，这个时候基本上都是通过相应的第三方中间件来实现，这就容易造成 10 个人去使用可能就有 10 种使用的方式，一部分会造成技术栈不统一，另外也会不便于管理。

Egg 定位于企业级应用开发 （引入 Router-路由，Config-基础配置，Logger-日志，定时任务）按照功能特点每一类文件必须按照约定放在对应目录，省去了一些技术选型的耗时也统一了技术差异，遵循约定使处理自动化，比如中间件要放在 middleware 目录。

内置日志中间件，约定了日志目录。

Egg 内置了 cluster(聚集)模式，能够实现 master 和 worker 多进行启动，且实现了进程间的通信。这能提升 Node 服务的性能和稳定性。

异常处理

提供了可配置处理方式，可以再捕获错误后跳转到 HTML 页面（500、404）-对用户体验较好,可以返回 JSON , 也可以返回文本。

安全

内置 XXS，SSRF，CSRF 等攻击的防御，提供 IP 白名单机制，钓鱼攻击的防御方案。

## 6. nest.js 有去用过么？

嗯 目前确实没有使用过，只知道是基于 `express` 的一种全功能架构，对 TS 支持比较好。

## 7. 之前用 koa2 都用过哪些中间件？

- `koa-bodyparser`：解析请求体

  ```js
  const Koa = require('koa');
  const bodyParser = require('koa-bodyparser');

  const app = new Koa();
  app.use(bodyParser());

  app.use(async (ctx) => {
    //可以获取到request.body
    ctx.body = ctx.request.body;
  });
  ```

- `koa-static` ：处理静态资源
- `koa-convert`：由于 koa-static 目前不支持 koa2 所以只能用 koa-convert 封装一下

  ```js
  const Koa = require('koa');
  const static = require('koa-static');

  const app = new Koa();

  const staticPath = './static';

  //即可直接通过'./static'，访问到静态资源
  app.use(static(path.join(__dirname, staticPath)));

  app.listen(3000, () => {
    console.log('端口号是 3000');
  });
  ```

- `koa-router`：路由

  ```js
  const router = require('koa-router')();
  router.post('/goods/addClass', goodsController.addGoodsClass);
  q;

  router.use('/api', user.routes());
  ```

- `koa-logger`、`koa-onerror`做一些日志的处理。
- `node-schedule`：做一些定时任务。
- `koa-jwt`、`jsonwebtoken`：做一些登陆态校验和 token。
  ```js
  const jwt = require('jsonwebtoken');
  app.use(async (ctx, next)=>{
      const { url, header } = ctx.request
      // 只检验后台接口
      if(url.indexOf('/api') > -1 && url.indexOf('wx') === -1){
          const token = header['auth-token']
          if (token) {
          let payload = jwt.verify(token, 'test', async (err, decode)=> {
              if (err) {
                  if (err.name == 'TokenExpiredError') {
                      ctx.body = {
                          code: decode,
                          msg: 'token已过期'
                      }
                  } else if (err.name == 'JsonWebTokenError') {
                      ctx.body = {
                          code: decode,
                          msg: '无效的token'
                      }
                  }
              } else {
                      await next()
                  }
              }
          })
          }
      } else {
          ctx.body = {
              code: 1000,
              msg: '登录信息已过期'
          }
      }
          return await next()
      }
      await next()
  })
  app.use(koajwt({ secret: SECRET }).unless({
      // 登录接口不需要验证
      path: [/^\/api\/login/]
  }));
  ```
- `fast-csv`：做一些 csv 商品的批量倒入。
- `nodejs-websocket`：做了一些中后台消息推送。

## 8.XSS 和 CSRF？

- CSRF(Cross-site request forgery，跨站请求伪造)：主要是利用用户在打开一个网站 A 后，又开了一个 TabB，此时 B 利用 A 的登陆信息，让用户在 A 上做一些恶意的操作。

  - 验证 HTTP Referer 字段
  - 在请求地址中添加 token 并验证；
  - 在 HTTP 头中自定义属性并验证。

- XSS(Cross-site Scripting, 跨站脚本攻击)：原理就是通过发布文章、发布评论等方式，将一段恶意的 JS 代码输入进去。然后别人再看这篇文章、评论时，之前注入的这段恶意 JS 代码就执行了。JS 代码一旦执行就跟网页原有的 JS 有同样的权限，可以获取 cookie 等

  - CSP(Content-Security-Policy) 内容安全策略：'Content-type':'text/html', 'Content-Security-Policy':'default-src http: https:' 那么返回的 html 文件就只能通过 http 和 https 外链加载 js 脚本的方式来执行 js 代码，而不能执行内联的 js 代码。
  - 对 cookie 设置 http-only
  - 对用户输入的内容进行 escape 验证，例如 React 框架本身对有风险的字符进行转义。
  - 后端对有 XSS 嫌疑的内容进行过滤。

## 9.你之前做的是直播能够说说这个项目主要做了什么吗？

首先，之前公司的业务主要涉及到 5 个端，主要是 H5、小程序、Android、IOS 和一些中后台系统。

我这边主要负责的是 H5、小程序、Hybrid 页面以及相对应的一些中后台系统。

当时的业务背景大致是这样：

1. 历史代码包袱较重，很多逻辑没有存在文档，导致在做一些新的业务时，需要耗费较长的时间去熟悉老业务。
2. 历史代码结构较混乱，内部业务耦合性太高，对于各类型直播间的通用能力没有抽离，存在大量的重复代码，容易造成业务改动遗漏的场景。
3. 之前的一些 UI 分层混乱，经常出现一些业务层级考虑不正确从而无法触发操作等情况，影响正常功能的使用。
4. 各端在业务上差异性较多，一方面是可能某个端功能残缺，另一方面是某个业务在四端可能有 4 种不同的表现形式。
5. 其他兄弟部分存在业务诉求，希望基于平台的直播能力实现某些定制化的业务。
6. 公司侧在做一些全平台的链路优化其中包含了全平台的 UI 风格统一。

基于以上 6 个原因，由业务线侧发起了长达 8 个月的直播 SDK 开发及重构相关的技术型迭代。

其中直播基础 SDK 主要包含 5 大功能模块：

1. 基础播放器，用于直播回放
2. 直播拉流播放器，用于播放各类型的直播场景
3. 直播聊天 IM 系统。
4. 直播弹幕和礼物系统。
5. 直播间联麦系统。

其中我主要负责除联麦外的功能开发，以及担任 IM 系统、弹幕和礼物系统的项目 PO。

**在技术选型上：**

- H5 侧播放器主要使用 React + Videojs + Flv.js + App 侧同层渲染播放器来实现，
- 小程序侧基于微信原生组件 live-player 封装
- IM 侧基于内部的一套 socket 以及腾讯云即时通讯 IM 来实现。
- 弹幕系统需要支持自定义弹幕

在迭代的过程中针对一些业务表现上的差异首先在 4 端做了调研，找产品进行了确认，梳理出了 4 端在功能上的差异性并进行了部分的统一。

对直播间的页面布局按照功能进行了详细的拆分，包括主流、副流、弹幕区、公告区、资源位区等。

播放器内按照不同的业务状态(页面初始化、直播中、暂离、自己的直播间)进行了拆分，提供了不同业务状态下的 slot 节点。

## 10. 在业务的迭代过程中有碰到什么困难？你是如何去解决的？

1. 部分业务侧层级混乱。

   在播放器的开发过程中，由于涉及到一些异常状态处理，比如说暂停、断网、流拉取异常、副流切换等场景发现部分业务侧的组件 z-index 异常，部分操作会影响。

   当时在发现这个问题的时候，首先第一步同步了其他端的开发者以及产品，确认了业务的正确层级。

   其次内部进行了讨论，制定了统一的 z-index 规范，比如播放器 z 值为 0，封面图 z 值为 1，其他一些正常的业务组件 z 值为 5，一级弹窗为 10 等。

   严格按照这套标准去分层，并把相对应的改动点同步给了测试。

   最终上线后没有出现过因为层级导致的一些 bug。

2. 播放器在不同端的兼容性问题。

   1. 例如 H5 侧在 Chrome 等浏览器上无法自动播放，通过修改网站设置--声音来支持，其他浏览器尝试进行自动播放，失败的话进行兜底 UI 展示。
   2. 在 ios 设备上不兼容 flv 格式的流，技术上优先检测是否支持 flv，不支持的情况下采用 hls 进行兜底。业务上公众号内部导向小程序直播间，App 内嵌页面采用同层渲染的模式。
   3. ios 和安卓上播放器层级最高，通过设置`playsinline`以及`x5-video-player-type="h5-pag"`来解决播放器层级问题。
   4. 播放器布局问题，通过设置`x5-video-orientation="portraint"`启用竖屏模式。
   5. 播放器没有全屏，通过设置`object-fit: fill` 让视频内容充满整个 video 容器。

3. 某些业务在某一端实现困难。

   比如在 H5 侧不好去做小窗相关的一些功能，不好去做联麦相关的功能，不好做一些自动播放的事情。

   当时主要是跟产品侧先进行沟通，表述了在 H5 侧的能力限制，再通过在会议上进行敲定。

4. 做弹幕体系的时候存在测试资源紧张的问题。

   当时的情况是这样的，本身线上的一些业务场景在测试环境不好复现，需要走的流程比较长，也需要占用较多的测试资源。

   因此需要一个工具能够帮助开发进行自行模拟相关的一些业务场景，尽量在开发阶段就覆盖到全场景，避免在测试阶段暴露出来过多的问题。

   得益于之前在做业务迭代的同时，我已经将 H5 侧所有的 IM 场景进行了梳理并进行了落地。在基于这个文档的基础上主动联合后端提供了一个后端侧的 API 另外由于我自己学过 python 相关的一些知识，利用 python 做了一个自动转发的小工具，提供给了其他端和测试使用。

   这样在开发阶段基本上就覆盖了所有的场景，并且释放了大量的测试资源，因为之前很多时候都是需要测试配合。

   后来也将这块功能集成到了内部的 QA 系统中，形成了业务线内的常用工具。

5. 做 IM 的时候也碰到了紧急项目打乱现有项目排期的问题。

   SDK 的项目属于技术型迭代由业务线发起，当时的项目优先级为 p1，当时做这块的时候来了老板的一个 p0 级需求。

   本来这一块是我和另外一个人一起负责的，因为紧急需求的问题，为了团队的输出及保障高优先级任务，我在完成自己这块的同时，接手了这位同事的工作。

   项目排期本身就比较紧张，我也主动加班加点完成了任务。

## 11. 你觉得这个项目上最大的收获是什么？

1. 提供了全平台的基础直播能力，在解决历史代码包袱，提升开发效率的的同时提供了统一的解决方案，方便其他业务快速接入，在后期业务迭代中极大的缩短了项目的开发周期。

2. 通过这个项目，加强了自己以及成员对业务的理解，同时也提升了业务线以及自己团队在公司层面的影响力。

3. 在实施项目的过程中提升了自己的风险应对能力，项目管理能力，跨团队的沟通能力以及演讲表达能力。

4. 通过这个项目也落地了一些团队内的业务规范，包括命名规范、文档规范、UI 规范、组件设计规范、CR 规范等，带动了一些核心成员的能力成长。

## 12. 你觉得这项目中有待改进的点是什么？

## 13.splitChunks

```js
splitChunks: {
      chunks: 'async', // 仅提取按需载入的module
      minSize: 30000, // 提取出的新chunk在两次压缩(打包压缩和服务器压缩)之前要大于30kb
      maxSize: 0, // 提取出的新chunk在两次压缩之前要小于多少kb，默认为0，即不做限制
      minChunks: 1, // 被提取的chunk最少需要被多少chunks共同引入
      maxAsyncRequests: 5, // 最大按需载入chunks提取数
      maxInitialRequests: 3, // 最大初始同步chunks提取数
      automaticNameDelimiter: '~', // 默认的命名规则（使用~进行连接）
      name: true,
      cacheGroups: { // 缓存组配置，默认有vendors和default
        vendors: {
          test: /[\\/]node_modules[\\/]/, // 匹配需拆分chunk的目录
          priority: -10 // 拆分优先级
        },
        default: {
          minChunks: 2, // 覆盖外层minChunks,用于提取被引用指定次数的公共模块，这里默认2次
          priority: -20,
          reuseExistingChunk: true // 是否重用已存在的chunk
        }
      }
    }
```

## 14. 如何带领好团队？

## 15. 项目中做过哪些优化？

- 首先是资源请求方面：

  1. 对 CSS 资源进行合并，多个请求合并成一个，尽量不使用`@import`语法，采用`dns-prefetch`对需要加载的外部 CSS 文件进行 DNS 预解析操作，采用`Preconnect`进行预连接。
  2. 静态资源例如图片等走 CDN，并根据业务场景进行裁剪，压缩图片的质量，采用`webp`的格式代替 PNG。
  3. 减少请求数量，合并 js 请求和部分的接口请求，对于埋点脚本、上报脚本等采用`async`或者`defer`异步的方式去加载。
  4. 路由懒加载，仅加载页面所涉及到的路由。
  5. 部分通用型图标走`font-size`矢量图标库，减少不要的图片请求。
  6. CSS 放置在`<head>`中，js 放置在`<body>`标签之后。
  7. webview、图片、音视频资源的预加载以及采用骨架屏。

- 另外是资源压缩方面：

  1. 接口请求的返回数据走 gzip 压缩。
  2. 某些常用的功能，比如说日期格式化等简单的方法走自定义实现，不去引用`moment.js`等库。
  3. 打包走`tree-shaking`删除无用代码，配置`externals`将通用代码通过 CDN 引入，通过使用`webpack-bundle-analyzer`等插件删除或修改代码，生成 bundle 的时候通过`uglifyjs`进行压缩。
  4. 通用型 CSS 样式走全局样式，业务型样式走`CSS-Module`，通用型 js 方法也是如此。
  5. 合理命名样式名，减少 CSS 选择器的层级，合理使用 CSS 权重，避免过多的`!important`。
  6. 合理使用 CSS 的属性继承。
  7. 合理组织组件层级和架构，尽量做到可扩展性较强。

- 缓存方面：

  1. 主要使用强缓存，部分业务走前端本地缓存，加速渲染。
  2. 某些功能采用`server-worker`进行缓存。

- 运行时优化：
  1. 减少业务回流，使用切换样式名的方式代替某些 DOM 节点变更，采用 transform 代替 left 等偏移计算。
  2. 针对某些复杂型的计算放入到 web worker 中去执行，计算完成后通知主线程。
  3. 基本采用 flex 布局来实现页面布局，对于某些动画等元素尽量采用`absolute`定位的方式去加速渲染，因为合成层的位图，会交由 GPU 合成，比 CPU 处理要快。
  4. 采用`requestAnimationFrame`避免强制同步布局，避免过多的 Long Task，将一些不重要的方法放入到`requestIdleCallback`中来。
  5. 代码的合理拆分，实现遍历的时候使用恰当的方式。
  6. 对一些用户的操作做一些防抖和截流。
  7. 对于列表和图片采用懒加载的方式。

## 16. 如何做好团队建设

1. 明确团队目标。像之前我们是一种月度 PBC 制度，每个月的中下旬都会去探讨下个月要完成的一些任务，并给这些任务进行资源的预估以及项目的排期工作。评估完成后会进行组内的会议沟通，明确下个月需要完成的任务目标以及核心任务，确保每个人都能够清晰的知道努力的方向。

2. 营造良好的沟通和学习氛围。多与团队成员沟通，并采用合理的方式。比如通过周会，月会的形式去了解本周，本月在工作上碰到的一些问题以及对产品或者业务有什么建议，去引导成员更好的去表达自己的想法。

通过一对一的方式去了解每位成员近期的一些想法，包含工作上顺不顺心，有没有什么困恼，和其他人员沟通上有没有碰到什么困难？在业务上有没有什么诉求，是想去做一些偏 H5 侧的任务呢？还是想多做一些有挑战性的一些任务？

在学习氛围建设上呢，我会将一些自己看了觉得好的一些优秀的文章以及一些行业上好的解决方式共享到组内小群。

通过询问的方式也购买了一些成员想要看的一些书籍。

同时每两周组织团队内外的一些技术分享，可以分享一些业务上的心得或者是技术上的收获。

3. 建立与成员之前的信任。

   在成员碰到技术难题的时候能够主动的去帮助他们一起解决，在碰到需要其他团队成员协助的时候能够帮助他们去协调资源。

   支持他们去做事，并能够在出现问题的时候进行兜底，就算最后真的出了问题也用于承担。

   比如像之前在一些业务迭代中，有个组员发现这块历史逻辑上存在可以优化的一些点，主动的反馈给我了。

   通过了解后，确实认为这块功能在业务上可以进行优化。首先对其进行了肯定，然后表达了具体的流程我们可以先整理下思路，看下这块功能调整的风险是不是可控，在这个项目周期内能不能完成。

   可控并且能够完成的情况下，然后先跟产品去沟通一下，看看产品是不是认同我们这个方案。假设人头的情况下，我们第一时间也要去项目群去同步下这个事情，让其他端的小伙伴以及测试都能够第一时间知道这个事情。

   另外有一次业务迭代的过程中，有一个组员发现了一些历史 bug，也第一时间同步给了我。和他一起确认了真确的业务逻辑后，这一块也交给他做了。在上线后确实解决了这个问题，但由于当时还没有业务层级规范，不小心造成了一个新的线上 bug，也被用户发现并反馈了过来。

   在反馈后第一时间进行了排查，发现是层级原因导致，自测后也让测试把关了下，迅速的进行了上线。

   但由于内部的一些 bug 制度，需要对这个事件进行定性的考核。业务 PM 这边在做了了解后，建议把这个责任人定位成这位同学，但是我主动进行了一个揽责。

   首先，这个问题的造成一定程度上确实在于我，没有建立一个统一的业务层级规范。

   其次，成员有想法是好的，能够主动的去思考业务，并且提出业务中可以去优化以及存在的一些问题，这值得去肯定，在实现的过程中肯定都是希望不要出问题的，如果一出了问题就将他推出去问责，一个会打击他本身的积极性，另外一个也会影响团队整体的信任度。

4. 培养核心成员。

   - 通过平时的观察选择出意向成员。
   -

5. 尽量的为团队成员争取应得的一些福利。

## 17. Mobx 和 Redux 有什么区别？

### 设计思想

| 框架  | 思想                                                                                                                                                                     |
| :---- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Redux | `函数式编程`，如`reducer`就是一个`纯函数（pure function）`，接受输入，然后输出结果，除此之外不会有任何影响，也包括不会影响接收的参数；对于相同的输入总是输出相同的结果。 |
| Mobx  | `面向对象编程（OOP）`和 `响应式编程（Reactive Programming）`，将 js 对象包装成`可观察对象`，一旦数据发生变化，就会自动更新。                                             |

### Store 管理方式

| 框架  | 思想                                                              |
| :---- | :---------------------------------------------------------------- |
| Redux | `Redux`中我们习惯于将所有共享的应用数据集中在一个大的`Store`中。  |
| Mobx  | 在`Mbox`则通常按模块将应用状态划分，在多个独立的 `store` 中管理。 |

### 数据类型差异

| 框架  | 思想                                                                              |
| :---- | :-------------------------------------------------------------------------------- |
| Redux | `Redux`中默认以`JavaScript原生对象`形式存储数据，需要手动追踪所有状态对象的变更。 |
| Mobx  | 在`Mbox`中使用特有的`可观察对象(Observal Object)`，当数据发生变更时自动触发更新。 |

### 数据可变性差异

| 框架  | 思想                                                                                                                                                 |
| :---- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| Redux | `Redux`中对象通常是`不可变的(Immutable)`，我们不能直接操作状态对象，而总是在原来状态对象基础上返回一个新的状态对象，这样就能很方便的返回应用上一状态 |
| Mobx  | 在`Mbox`中推荐使用`Action`进行对应的数据更新操作，但是也允许在非严格模式下直接使用新值去更新状态对象                                                 |

### 使用方式差异

| 框架  | 使用方式                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :---- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Redux | 使用 `Redux` 和 `React` 应用连接时，需要使用 `react-redux` 提供的 `Provider` 和 `connect`。<li style="text-indent:2em;padding: 0.25em 0;">`Provider`:负责将 `Store` 注入 `React` 应用。</li> <li style="text-indent:2em;padding: 0.25em 0;">`connect`:负责将 `store`、`state` 注入容器组件，并选择特定状态作为容器组件`props`传递。</li>                                                                                                                    |
| Mobx  | 使用 `Mobx` 和 `React`应用连接时，需要使用 `mobx-react` 提供的 `Provider` 和 `inject` 以及 `observer`API。<li style="text-indent:2em;padding: 0.25em 0;">`Provider`:负责将 `Stores` 注入 `React` 应用。</li> <li style="text-indent:2em;padding: 0.25em 0;">使用 `inject` 将特定 `store` 注入某组件，`store` 可以传递状态或 `action`；然后使用`observer` 保证组件能响应 `store`中的可观察对象（observable）变更，即 `store` 更新，组件视图响应式更新。</li> |

### 优劣势对比

| 框架  | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| :---- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Redux | <li>数据流流动单一比较清晰，任何 `dispatch` 都会导致广播，需要依据对象引用是否变化来控制更新粒度。</li><li>方便利用时间回溯的特征，可以增强业务的可预测性与错误定位能力(通过中间件可以记录前后的数据差异)。</li><li>时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 `immutable`。</li><li>引入中间件，其实主要为了解决异步带来的副作用，业务逻辑或多或少参杂着 `magic`。但是灵活利用中间件，可以通过约定完成许多复杂的工作。</li> |
| Mobx  | <li>数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。</li><li>自始至终一份引用，没有时间回溯能力，不需要 `immutable`，也没有复制对象的额外开销。</li> <li>由于没有 `magic`，所以没有中间件机制，没法通过 `magic` 加快工作效率（这里 `magic` 是指 `action` 分发到 `reducer` 的过程）。</li><li>完美支持 `typescript`。</li>                                                                                          |

## 18. mobx 的实现原理

主要是基于一种观察者模式，把一些需要观察的对象搜集到 observabel 对象中来，一旦 Observable 被修改，会调用 set 方法，就是依次执行该 Observable 之前收集的依赖函数，当前函数就会自动执行。

observer 这个装饰器，对 React 组件的 render 方法进行 track。将 render 方法，加入到各个 observable 的依赖中。当 observable 发生变化，track 方法就会执行。

track 中，还是先进行依赖收集，调用 forceUpdate 去更新组件，一个 mobx 添加的周期 componentWillReact，也会在此时执行。然后结束依赖收集。

每次都进行依赖收集的原因是，每次执行依赖可能会发生变化。
