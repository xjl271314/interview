1. 浏览器缓存有去了解过么？主要都有哪些缓存。

强缓存和协商缓存。

浏览器进行资源请求时，会判断 responese header 是否命中强缓存，如果命中，直接从本地读取缓存，不会发送请求到服务器。

如果未命中强缓存，会发送请求到服务器，判断协商缓存是否命中，如果命中的话，服务器会将请求返回(304)，但是不会返回资源，告诉浏览器直接从本地读取缓存。如果不命中，服务器会直接返回资源。

因为一般只有 GET 请求才会被缓存。

强缓存主要是 cache-control 和 Expires 字段

Expires 是一个 GMT 时间格式字符串,浏览器第一次请求的时候,服务器会在返回头部加上 Expires，下次请求的时候如果在这个时间之前那么命中缓存。

public、private、max-age、no-store、no-cache

协商缓存的话主要是 Last-Modified / If-Modified-Since 和 Etag / If-None-Match。

cache-control > Expires。

存在周期性重写某些资源，但资源实际包含的内容并无变化；
被修改的信息并不重要，如注释等；
Last-Modified 无法精确到毫秒，但有些资源更新频率有时会小于一秒。

相比于 Last-Modified 使用最后修改日期来比较资源是否失效的缓存校验策略，ETag 则是通过数据签名来做一个更加严格的缓存验证。

所谓数据签名，其实就是通过对资源内容进行一个唯一的签名标记，一旦资源内容改变，那么签名必将改变，服务端就以此签名作为暗号，来标记缓存的有效性。典型的做法是针对资源内容进行一个 hash 计算，类似于 webpack 打包线上资源所加的 hash 标识,随服务器 response 返回。

请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
如果资源没更改，返回 304，浏览器读取本地缓存。
如果资源有更改，返回 200，返回最新的资源。
不推荐使用 Expires 首部，它指定的是实际的过期日期而不是秒数。

ETag 有两种类型：

- 强校验：资源 hash 值具有唯一性，一旦变化则 hash 也变化。
- 弱校验：资源 hash 值以 W/开头，若资源变化较小，则同样可能命中缓存。

HTML5 的离线存储（Application Cache）是基于一个 manifest 文件。

service work 可拦截请求和返回，缓存文件。sw 可以通过 fetch 这个 api，来拦截网络和处理网络请求，再配合 cacheStorage 来实现 web 页面的缓存管理以及与前端 postMessage 通信。

2. HTPPS 是什么为什么安全。

HTTP 明文传输容易被中间人劫持信息，进行修改。

利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。

客户端使用 https 的 url 访问 web 服务器，要求与服务器建立 ssl 连接
服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
客户端利用公钥将会话秘钥对称加密, 并传送给服务端
服务端利用自己的私钥解密出会话秘钥，之后服务器与客户端使用秘钥加密传输

解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构 CA。

CA 负责核实公钥的拥有者的信息，并颁发认证"证书"，同时能够为使用者提供证书验证服务，即 PKI 体系。

基本的原理为，CA 负责审核信息，然后对关键信息利用私钥进行"签名"，公开对应的公钥，客户端可以利用公钥验证签名。CA 也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。

证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名;

3. HTTP keep-alive 和 TCP keepalive 的区别

TCP，双方长时间未通讯时，如何得知对方还活着

HTTP 请求。客户端的每一次请求都要和服务端创建 TCP 连接，服务器响应后，断开 TCP 连接。下次客户端再有请求，则重新建立连接。

这样无疑省略了反复创建和销毁 TCP 连接的损耗。

4. DNS 解析过程

DNS 解析过程是将域名解析成 IP 地址的过程。

1. 查找浏览器缓存 TTL
2. 查找系统缓存(hosts 缓存)
3. 查找路由器缓存
4. 查找 ISP DNS 缓存
5. DNS Lookup 迭代查询

6. 什么是预请求(options 请求)?

预请求就是发起那些复杂请求(例如 put、delete 等)时会先发送一个 OPTIONS 方法进行请求的嗅探，以判断是否有对指定资源的访问权限。

为什么需要进行预请求?

w3c 规范要求，对复杂请求，浏览器必须先使用 options 发起一个预检请求，从而获知服务器是否允许该跨域请求，服务器确认以后才能发起实际的 HTTP 请求，否则停止第二次正式请求。

如何优化预请求?

1. 对于某些跨域请求采用 JSONP 的方式进行请求，从而绕过预请求。
2. 服务端设置对应的 Access-Control-Max-Age 字段，在第一次请求时进行预检后续请求不进行预检。该字段返回的值是秒数。

3. 前端代码复杂度

圈复杂度 + eslint 校验。

重构 降低业务代码的圈复杂度。

7. 怎么去检验页面的性能指标呢？

RAIL

response

animation

idle

load

8. rollup 和 webpack 最大的区别是 tree shaking 的程度

rollup 就不会有这种问题，它基于原生 ESM 模块，在编译时就能分析出哪些是没有使用的代码（webpack 还要额外配置）。所以 rollup 打包出来的代码非常干净。

9. 使用 jekins 基于 pipeline 构建项目

10. 基于 github access_token + Travices CI 构建
