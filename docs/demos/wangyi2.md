---
title: 网易模拟面试题后端部分
nav:
  title: 模拟试题
  path: /demos
  order: 0
group:
  title: 技术部分
  path: /demos/technology
---

# 网易模拟面试题后端部分

- 2022.11.19

## 1.之前都接触过哪些后端语音？

之前在学校的时候学过 C 语音、C++、C#相关的知识，也包括了 SQL Server 等一些数据库。

后来刚开始工作的时候呢是在温州那边，当时还是 Jquery 盛行的时代，所以业务中也会用到 PHP 相关的一些技术，当时呢也有个师傅带自己恰好呢他自己也又一套完整的 PHP 的教学视频也就边工作边学习撸完了整套的 PHP 课程，后来自己毕业设计做了个商场，后端也是自己用 PHP 搭起来的。

在后来来了杭州，开始接触了`Node.js`用来做一些内部的管理系统以及一些数据、监控后台，那时也接触了像 Mongo DB 相关的一些非关系型数据库。

后来自己做一些项目的时候涉及到一些数据爬取之类的需求，又自学了`Python3`相关的一些知识，能够做一些工具，做一些简单的数据爬虫。

大致上接触的就是这么个样子。

## 2. 之前又接触过 GO 吗？

自己本身是没有学习过 Go 的，不过之前公司内部有些服务也是用 Go 去编写的，周六的话自己花了一些时间学习了下。

## 3. 你觉得 Go 和其他语言比如说 PHP 相比，存在着哪些优势？

1. 优雅且简洁，书写方式上我感觉和 JS、Swift、Python3 差距不大，在一些错误处理上又有点 OC 的感觉。
2. 性能上来说更好，适合处理高并发等业务场景。
3. 像 JS 一样也有自己的垃圾回收机制，又有自己三方插件库。

## 4. 关系型数据库和非关系型有什么区别？

### 关系型

现在使用比较多的应该说是`mysql`吧。

**优点**

- 容易理解，因为它采用了`关系模型`来组织数据，采用`表格`的方式存储数据。
- 通过`事务`的方式高度保持数据的一致性。
- 使用通用的结构化查询语句(SQL 语句)
- 可以做复杂的查询，支持使用`join`、`where`等条件做复杂的筛选查询

**缺点**

- 在海量信息的时候读写能力差
- 数据存储格式较单一，且在设计时需要考虑可扩展性，避免长度等问题导致字段格式修改
- 固定的表结构，灵活度欠佳
- 高并发读写时，磁盘 IO 存在瓶颈
- 可扩展性不足，不像 web server 和 app server 那样简单的添加硬件和服务节点来拓展性能和负荷工作能力。

### 非关系型

**优点**

- 可存储的数据格式更加丰富，采用`key-value`、文本、图片等形式来存储，例如`redis`、`mongoDB`。
- 性能优越：NOSQL 是根据键值对的，不用历经 SQL 层的分析，因此 性能非常高。
- 可扩展性好：基于键值对，数据之间耦合度极低，因此容易水平扩展。

**缺点**

- 无事务处理机制；
- 不支持 sql，学习和运用成本比较高；
- 数据结构导致复杂查询不容易实现。

## 5. 关系型数据库的 ACID 原则是什么？

- `A(Atomicity原子性)`：原子性意味着数据库中的事务执行是作为原子，即不可再分。整个语句要么执行，要么不执行，不会有中间状态。
- `C(Consistency一致性)`：事务在开始和结束时，应该始终满足一致性约束。比如系统要求 A+B=100,那么事务如果改变了 A 的数值，则 B 的数值也要相应修改来满足这样一致性要求；
- `I(Isolation隔离性)`：如果有多个事务同时执行，彼此之间不需要知晓对方的存在，而且执行时互不影响，事务之间需要序列化执行，有时间顺序。数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时，由于交叉执行而导致数据的不一致；
- `D(Durability持久性)`：事务的持久性是指事务运行成功以后，对系统状态的更新是永久的，不会无缘无故回滚撤销。即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。

## 6. mysql 现在默认的数据库引擎是什么？ 与之前的有什么差别？

默认最新的版本好像是`8.0.11`，但是印象中从`5.5`开始默认都是`InnoDB`的引擎。

InnoDB 和 MyISAM 主要差异在以下 5 个点：

- 数据的存储结构不同。
- 存储空间的消耗不同。
- 对事务的支持不同。InnoDB ⽀持事物，⽽ MyISAM 不⽀持事物。
- 对锁的支持不同。InnoDB ⽀持⾏级锁，⽽ MyISAM ⽀持表级锁。
- 对外键的支持不同。InnoDB ⽀持外键，⽽ MyISAM 不⽀持。

## 7. SQL 语句的执行流程是什么？

1. 客户端请求 -> 连接器（验证用户身份，给予权限）。
2. 查询缓存，存在直接返回，否则进行下一步。
3. 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。
4. 根据优化器生成的执行计划，再调用存储引擎的 API 来执行查询。
5. 将结果返回给客户端。

## 8. 什么是索引？

索引是⼀种数据结构，主要用来帮助我们加速查找到想要的数据。

## 9. 那么索引是是什么数据结构？

主要是`Hash索引`和`B+树`，不过在`InnoDB引擎`下，默认是`B+树`。

## 10. Hash 索引和 B+树所有有什么区别或者说优劣呢?

- `hash索引`底层就是 hash 表，进⾏查找时，调⽤⼀次 hash 函数就可以获取到相应的键值，之后进⾏回表查询获得实际数据。
- `B+树`底层实现是`多路平衡查找树`.对于每⼀次的查询都是从根节点出发，查找到叶⼦节点⽅可以获得所查键值，然后根据查询判断是否需要回表查询数据.

- `hash索引`进⾏`等值查询更快`(⼀般情况下)，但是却⽆法进⾏范围查询，相对来说在 NoSQL 引擎中使用较多。

  **为什么不能进行范围查询呢？**

  因为在`hash索引`中经过 hash 函数建⽴索引之后，索引的顺序与原顺序⽆法保持⼀致。

  ⽽`B+树`的的所有节点皆遵循(左节点⼩于⽗节点，右节点⼤于⽗节点，多叉树也类似)，天然⽀持范围。

- `hash索引`不⽀持使⽤索引进⾏排序。
- `hash索引`不⽀持模糊查询以及多列索引的最左前缀匹配。
- `hash索引`任何时候都避免不了回表查询数据，⽽`B+树`在符合某些条件(`聚簇索引`，`覆盖索引`等)的时候可以只通过索引完成查询.
- `hash索引`虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在⼤量重复的时候，发⽣`hash碰撞`，此时效率可能极差。⽽`B+树`的查询效率⽐较稳定，对于所有的查询都是从根节点到叶⼦节点，且树的⾼度较低.

**因此，在⼤多数情况下，直接选择`B+树索引`可以获得稳定且较好的查询速度.⽽不需要使⽤ hash 索引。**

## 11. 什么是聚簇索引？

在 B+树的索引中，叶⼦节点可能存储了当前的`key值`，也可能存储了当前的`key值`以及整⾏的数据，这就是聚簇索引和⾮聚簇索引。

在`InnoDB`中，**只有主键索引是`聚簇索引`**。

- 如果没有`主键`，则挑选⼀个唯⼀键建⽴`聚簇索引`。
- 如果没有唯⼀键，则隐式的⽣成⼀个键来建⽴`聚簇索引`。

当查询使⽤`聚簇索引`时，在对应的叶⼦节点，可以获取到整⾏数据，因此不⽤再次进⾏`回表查询`。

## 12. ⾮聚簇索引⼀定会回表查询吗?

不⼀定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进⾏回表查询。

举个简单的例⼦，假设我们在`员⼯表`的年龄上建⽴了索引，那么当进⾏`select age from employee where age < 20`的查询时，在索引的叶⼦节点上，已经包含了 age 信息，不会再次进⾏回表查询。

## 13. 在建⽴索引的时候，都有哪些需要考虑的因素呢?

建⽴索引的时候⼀般要考虑到字段的使⽤频率，经常作为条件进⾏查询的字段⽐较适合。

如果需要建⽴`联合索引`的话，还需要考虑联合索引中的顺序。

此外也要考虑其他⽅⾯，⽐如防⽌过多的索引对表造成太⼤的压⼒，这些都和实际的表结构以及查询⽅式有关。

## 14. 联合索引是什么? 为什么需要注意联合索引中的顺序?

`MySQL`可以使⽤多个字段同时建⽴⼀个索引，叫做`联合索引`。

在联合索引中，如果想要命中索引，需要按照建⽴索引时的字段顺序挨个使⽤，否则⽆法命中索引。

具体原因为:

**MySQL 使⽤索引时需要索引有序**，假设现在建⽴了`name,age,school`的联合索引。

那么索引的排序为:

- 先按照`name`排序
- 如果`name`相同,则按照`age`排序
- 如果`age`的值也相等，则按照`school`进⾏排序.

当进⾏查询时，此时索引仅仅按照`name`严格有序，因此必须⾸先使⽤`name`字段进⾏等值查询。

之后对于匹配到的列⽽⾔，其按照`age`字段严格有序，此时可以使⽤`age`字段⽤做索引查找。

以此类推......

因此在建⽴联合索引的时候应该注意索引列的顺序，⼀般情况下，将查询需求频繁或者字段选择性⾼的列放在前⾯。

此外可以根据特例的查询或者表结构进⾏单独的调整.

## 15.如何检查执行的语句是否使用了索引？

`MySQL`提供了`explain`命令来查看语句的执⾏计划。

![explain](https://img-blog.csdnimg.cn/62527f9d4d0a427d816f05b4d6295b07.png)

在执⾏某个语句之前，会将该语句过⼀遍`查询优化器`，之后会拿到对语句的分析，也就是执⾏计划。

其中包含了许多信息，可以通过其中和索引有关的信息来分析是否命中了索引，例如`possilbe_key`，`key`，`key_len`等字段，分别说明了此语句`可能会使⽤的索引`，`实际使⽤的索引`以及`使⽤的索引长度`。

## 16.什么场景下建立了索引但是实际没有去使用呢？

- 使⽤不等于查询，例如 WHERE 子句中的 OR 语句，只要有条件列不是索引列，就会进行全表扫描。
- 索引列参与了数学运算或者函数。
- 在字符串 like 时左边是通配符.类似于'%aaa'。
- 当 mysql 分析全表扫描⽐使⽤索引快的时候不使⽤索引。
- 当使⽤联合索引，前⾯⼀个条件为范围查询，后⾯的即使符合最左前缀原则，也⽆法使⽤索引。

## 17. 什么是事务？

事务指一系列的处理逻辑，要符合 ACID 特性。事务中的操作要么全部成功，要么全部失败。

## 18. 同时有多个事务在进⾏会怎么样呢?

多事务的并发进⾏⼀般会造成以下⼏个问题:

1. `脏读`: A 事务读取到了 B 事务未提交的内容，⽽ B 事务后⾯进⾏了回滚。

2. `不可重复读`: 当设置 A 事务只能读取 B 事务已经提交的部分，会造成在 A 事务内的两次查询，结果竟然不⼀样，因为在此期间 B 事务进⾏了提交操作。

3. `幻读`: A 事务读取了⼀个范围的内容，⽽同时 B 事务在此期间插⼊了⼀条数据，造成"幻觉"。

## 19. 怎么解决这些问题呢? MySQL 的事务隔离级别了解吗?

主要有四种隔离级别：

1. 未提交读(READ UNCOMMITTED)

这个隔离级别下，其他事务可以看到本事务没有提交的部分修改，因此会造成脏读的问题(读取到了其他事务未提交的部分，⽽之后该事务进⾏了回滚)。

2. 已提交读(READ COMMITTED)

其他事务只能读取到本事务已经提交的部分.这个隔离级别有不可重复读的问题，在同⼀个事务内的两次读取，拿到的结果竟然不⼀样，因为另外⼀个事务对数据进⾏了修改.

3. REPEATABLE READ(可重复读)

可重复读隔离级别解决了上⾯不可重复读的问题(看名字也知道)，但是仍然有⼀个新问题，就是`幻读`。

当读取`id > 10` 的数据⾏时，对涉及到的所有⾏加上了`读锁`，此时例外⼀个事务新插⼊了⼀条`id=11`的数据，因为是新插⼊的，所以不会触发上⾯的锁的排斥。

那么进⾏本事务进⾏下⼀次的查询时会发现有⼀条`id=11`的数据，⽽上次的查询操作并没有获取到，再进⾏插⼊就会有主键冲突的问题。

4. SERIALIZABLE(可串⾏化)

这是最⾼的隔离级别，可以解决上⾯提到的所有问题，因为他强制将所以的操作串⾏执⾏，这会导致并发性能极速下降，因此也不是很常⽤。

## 20.上面提到了幻读，这个问题要这么解决？

幻读出现的场景：

- 事务的隔离级别是可重复读，且是当前读。
- 幻读指新插入的行。

幻读带来的问题：

- 对行锁语义的破坏
- 破坏了数据一致性

解决方案：

- 加`间隙锁`，锁住行与行之间的间隙，阻塞新插入的操作。
- 带来的问题：降低并发度，可能导致死锁。

## 21.InnoDB 使⽤的是哪种隔离级别呢?

`InnoDB`默认使⽤的是可重复读隔离级别。

## 22. 对 MySQL 的锁了解吗?

当数据库有并发事务的时候，可能会产⽣数据的不⼀致，这时候需要⼀些机制来保证访问的次序，锁机制就是这样的⼀个机制。

就像买高铁票一样，一个位置只能卖给一个人。除非之前的人到站了。

## 23. MySQL 都有哪些锁呢? 像上⾯那样⼦进⾏锁定岂不是有点阻碍并发效率了?

从锁的类别上来讲，有`共享锁`和`排他锁`。

- `共享锁`: ⼜叫做读锁.当⽤户要进⾏数据的读取时，对数据加上共享锁，共享锁可以同时加上多个。
- `排他锁`: ⼜叫做写锁.当⽤户要进⾏数据的写⼊时，数据加上排他锁.排他锁只可以加⼀个，他和其他的排他锁、共享锁都相斥。

锁的粒度取决于具体的`存储引擎`，InnoDB 实现了`⾏级锁`、`页级锁`、`表级锁`。

## 24. 为什么主键尽量只设定一个呢？

主键是数据库确保数据⾏在整张表唯⼀性的保障，即使业务上本张表没有主键，也建议添加⼀个⾃增长的 ID 列作为主键.设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。

## 25. 主键使⽤⾃增 ID 还是 UUID?

推荐使⽤⾃增 ID，不要使⽤ UUID。

因为在`InnoDB`存储引擎中，主键索引是作为聚簇索引存在的。也就是说，主键索引的 B+树叶⼦节点上存储了主键索引以及全部的数据(按照顺序)。

- 如果主键索引是⾃增 ID，那么只需要不断向后排列即可，
- 如果是 UUID，由于 ID 不一致性，会造成⾮常多的数据插⼊、数据移动，然后导致产⽣很多的内存碎⽚，进⽽造成插⼊性能的下降。

## 26. 字段为什么要求定义为 not null？

null 值会占⽤更多的字节，且会在程序中造成很多与预期不符的情况。

## 27. 如果要存储⽤户的密码散列，应该使⽤什么字段进⾏存储?

固定长度的字符串应该使⽤`char`⽽不是`varchar`来存储，这样可以节省空间且提⾼检索效率。

## 28. 超大的分页如何进行处理？

主要是靠缓存，可预测性的提前查到内容，缓存⾄ redis 等 k-V 数据库中，直接返回即可。

可预测性的查可以通过优化子查询等方式进行。

## 29. 数据库的三大范式是什么？

- 第一范式：每个列都不可以再拆分。
- 第二范式：⾮主键列完全依赖于主键，⽽不能是依赖于主键的⼀部分。
- 第三范式：⾮主键列只依赖于主键，不依赖于其他⾮主键。

## 30. MySQL 的 change buffer 是什么？

- 当需要更新一个数据页时，如果数据页在内存中就直接更新；而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 `change buffer` 中。

- 这样就不需要从磁盘中读入这个数据页了，在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

- 注意唯一索引的更新就不能使用 `change buffer`，实际上也只有普通索引可以使用。

适用场景：

对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 `change buffer` 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。

## 31. MySQL 的 redo log 和 binlog 区别？

|      字段       | redo log                                     | binlog                                                                           |
| :-------------: | :------------------------------------------- | :------------------------------------------------------------------------------- |
|      作用       | 用于崩溃恢复                                 | 主从复制和数据恢复                                                               |
|    实现方式     | InnoDB 存储引擎实现                          | Server 层实现，所有的存储引擎都可以使用到 binlog 日志                            |
|    记录方式     | 循环写的方式记录，写到结尾时会回到开头写日志 | 通过追加的方式记录，当文件尺寸大于配置 🈯 值的时候，后续的日志会记录到新的文件上 |
|    文件大小     | redo log 的大小是固定的                      | 通过配置参数 max_binlog_size 设置每个 binlog 的文件大小                          |
| crash-safe 能力 | 具有                                         | 没有                                                                             |
|    日志类型     | 逻辑日志                                     | 物流日志                                                                         |

## 32. 为什么需要 redo log？

- redo log 主要用于 MySQL 异常重启后的一种数据恢复手段，确保了数据的一致性。
- 其实是为了配合 MySQL 的 WAL 机制。因为 MySQL 进行更新操作，为了能够快速响应，所以采用了异步写回磁盘的技术，写入内存后就返回。但是这样，会存在 crash 后 内存数据丢失的隐患，而 redo log 具备 crash safe 的能力。

## 33. 之前都在用 koa，那么能说说 koa 的中间件原理么？

先看一段示例代码：

```js
const Koa = require('koa');
const app = new Koa();

// logger
app.use(async (ctx, next) => {
  await next();
  const rt = ctx.response.get('X-Response-Time');
  console.log(`${ctx.method} ${ctx.url} - ${rt}`);
});

// x-response-time
app.use(async (ctx, next) => {
  const start = Date.now();
  await next();
  const ms = Date.now() - start;
  ctx.set('X-Response-Time', `${ms}ms`);
});

// response
app.use(async (ctx) => {
  ctx.body = 'Hello World';
});

app.listen(3000);

// 执行顺序
// Hello World
// ctx.set('X-Response-Time', `${ms}ms`)
// console.log(`${ctx.method} ${ctx.url} - ${rt}`);
```

如何自己实现中间件

```js
const http = require('http');

class Koa {
  constructor() {
    this.middleWareList = [];
  }

  // 实现 app.use(ctx, next) 用于注册中间件
  use(fn) {
    this.middleWareList.push(fn);
    // 返回this用于链式调用
    return this;
  }

  // 实现 compose方法
  compose(middleWareList) {
    return function (ctx, next) {
      function dispatch(i) {
        const fn = middlewareList[i];
        try {
          return Promise.resolve(
            fn(ctx, function next() {
              return dispatch.bind(null, i + 1);
            }),
          );
        } catch (err) {
          return Promise.reject(err);
        }
      }
      return dispatch(0);
    };
  }

  // 处理中间件的 http 请求
  handleRequest(ctx, middleWare) {
    // 这个 middleWare 就是 compose 函数返回的 fn
    // 执行 middleWare(ctx) 其实就是执行中间件函数，然后再用 Promise.resolve 封装并返回
    return middleWare(ctx);
  }

  // 将 req res 组合成为 ctx
  createContext(req, res) {
    // 简单模拟 koa 的 ctx ，不管细节了
    const ctx = {
      req,
      res,
    };
    return ctx;
  }

  // 生成 http.createServer 需要的回调函数
  callback() {
    const fn = this.compose(this.middlewareList);

    return (req, res) => {
      const ctx = this.createContext(req, res);

      return this.handleRequest(ctx, fn);
    };
  }

  // 实现listen(port)方法，核心就是使用http模块起一个服务
  listen(...args) {
    const server = http.createServer(this.callback());
    return server.listen(...args);
  }
}
```

## 34. 为什么 redo log 具有 crash-safe 的能力，是 binlog 无法替代的？

1. redo log 可确保 innoDB 判断哪些数据已经刷盘，哪些数据还没有

- redo log 和 binlog 有一个很大的区别就是，一个是循环写，一个是追加写。也就是说 redo log 只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志。
- 当数据库 crash 后，想要恢复未刷盘但已经写入 redo log 和 binlog 的数据到内存时，binlog 是无法恢复的。虽然 binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有。
- 但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中抹掉，因为是循环写！数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。

2. 如果 redo log 写入失败，说明此次操作失败，事务也不可能提交

- redo log 每次更新操作完成后，就一定会写入日志，如果写入失败，说明此次操作失败，事务也不可能提交。
- redo log 内部结构是基于页的，记录了这个页的字段值变化，只要 crash 后读取 redo log 进行重放，就可以恢复数据。

这就是为什么 redo log 具有 crash-safe 的能力，而 binlog 不具备。

## 35. 当数据库 crash 后，如何恢复未刷盘的数据到内存中？

根据 redo log 和 binlog 的两阶段提交，未持久化的数据分为几种情况：

- change buffer 写入，redo log 虽然做了 fsync 但未 commit，binlog 未 fsync 到磁盘，这部分数据丢失。
- change buffer 写入，redo log fsync 未 commit，binlog 已经 fsync 到磁盘，先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer。
- change buffer 写入，redo log 和 binlog 都已经 fsync，直接从 redo log 里恢复。

## 36. redo log 写入方式是什么？

redo log 包括两部分内容，分别是内存中的`日志缓冲(redo log buffer)`和`磁盘上的日志文件(redo log file)`。

MySQL 每执行一条 DML 语句，会先把记录写入 redo log buffer（用户空间） ，再保存到内核空间的缓冲区 OS-buffer 中，后续某个时间点再一次性将多个操作记录写到 redo log file（刷盘） 。这种先写日志，再写磁盘的技术，就是`WAL`。

![redo log写](https://img-blog.csdnimg.cn/265c4187a32d4e5e8dffff543e77ef2f.png)

可以发现，`redo log buffer`写入到`redo log file`，是经过`OS buffer`中转的。

其实可以通过参数`innodb_flush_log_at_trx_commit`进行配置，参数值含义如下：

- `0：称为延迟写`，事务提交时不会将 redo log buffer 中日志写入到 OS buffer，而是每秒写入 OS buffer 并调用写入到 redo log file 中。
- `1：称为实时写，实时刷`，事务每次提交都会将 redo log buffer 中的日志写入 OS buffer 并保存到 redo log file 中。
- `2：称为实时写，延迟刷`。每次事务提交写入到 OS buffer，然后是每秒将日志写入到 redo log file。

## 37. redo log 的执行流程?

假设执行的 SQL 如下：

```sql
update T set a =1 where id =666
```

![redo log 的执行流程](https://img-blog.csdnimg.cn/02fa422876bf49bf86d0bc59c685c8e8.png)

1. MySQL 客户端将请求语句 `update T set a =1 where id =666`，发往 `MySQL Server 层`。
2. MySQL Server 层接收到 SQL 请求后，对其进行分析、优化、执行等处理工作，将生成的 SQL 执行计划发到 InnoDB 存储引擎层执行。
3. InnoDB 存储引擎层将 a 修改为 1 的这个操作记录到内存中。
4. 记录到内存以后会修改 redo log 的记录，会在添加一行记录，其内容是需要在哪个数据页上做什么修改。
5. 此后，将事务的状态设置为 `prepare`，说明已经准备好提交事务了。
6. 等到 MySQL Server 层处理完事务以后，会将事务的状态设置为 commit，也就是提交该事务。
7. 在收到事务提交的请求以后，redo log 会把刚才写入内存中的操作记录写入到磁盘中，从而完成整个日志的记录过程。

## 38. SQL 语句类型有哪些？

- DDL 数据定义语言
- TPL 事务处理语言
- DCL 数据控制语言
- DML 数据操作语言

## 39. 数据操作语言主要有哪些？

- select
- insert
- update
- delete

## 40. join 从局总共有几种？

- 内连接 inner join
- 全外连接 full outer
- 左外连接 left join
- 右外连接 right join
- 交叉连接 cross join

### 内连接

将 2 张表的公共部分连接在一起。

- user 表

| id  | name | gender | age |
| :-- | :--- | :----- | :-- |
| 1   | 小明 | 男     | 16  |

- comment 表

| id  | userID | comment      |
| :-- | :----- | :----------- |
| 1   | 1      | Mysql 真有趣 |

```sql
SELECT a.*, b.comment FROM user as a INNER JOIN comment as b
ON a.id = b.userID
```

| id  | name | gender | age | comment      |
| :-- | :--- | :----- | :-- | :----------- |
| 1   | 小明 | 男     | 16  | Mysql 真有趣 |

### 左外连接

连接的时候以左表为基础，返回左表所有的字段以及右表连接的字段相等的值，如果要过滤右表不存在的数据可使用`b.key is NULL`。

### 右外连接

连接的时候以右表为基础，返回右表所有的字段以及左表连接的字段相等的值。

### 全外连接

返回两张表的所有字段。

**在 mysql 中不支持全连接，可以使用 left join union right join**

### 交叉连接

又称笛卡尔连接，如果 A 和 B 是两个集合，那么返回结果就是 A\*B。

## 40.如何更新使用过滤条件包括自身的表?

- user 表

| id  | name | gender | age |
| :-- | :--- | :----- | :-- |
| 1   | 小明 | 男     | 16  |
| 2   | 小白 | 男     | 14  |

- comment 表

| id  | userID | comment      |
| :-- | :----- | :----------- |
| 1   | 1      | Mysql 真有趣 |
| 2   | 1      | go 真有趣    |

比如说我想把 user 表中用户同时出现在评论表的用户的年龄都更新为 15。

```sql
UPDATE user SET age = 15  WHERE user.id IN(SELECT userID from comment as c  JOIN  user u  ON c.userID = u.id )
```

这时候报错信息：`Error Code: 1093. You can't specify target table 'user' for update in FROM clause`

```sql
UPDATE user as u JOIN (
SELECT userID from comment as c  JOIN  user u  ON c.userID = u.id
) b ON b.userID = u.id SET u.age = 15
```

```sql
UPDATE user SET age = 15 WHERE id IN(SELECT userID from comment)
```
