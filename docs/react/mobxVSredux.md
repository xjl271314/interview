---
title: Mobx 与 Redux
nav:
  title: React
  path: /react
  order: 0
group:
  title: react相关试题
  path: /react/project
---

# Mobx VS Redux

- 2022.01.21

## Mobx 原理

![核心思想](https://cn.mobx.js.org/flow.png)

## MobX 4 vs MobX 5

`MobX 4` 和 `MobX 5` 的不同之处在于后者使用了 `ES6` 的 `proxy` 来追踪属性。因此，`MobX 5` 只能运行在支持 `proxy` 的浏览器上，而 `MobX 4`可以运行在任何支持 `ES5` 的环境中。

### MobX 4 的重要局限性

在 `mobx4` 中使用 `bject.defineProperty` 来拦截对数据的访问，一旦值发生变化，将会调用 `react` 的 `render`方法来实现重新渲染视图的功能或者触发 `autorun` 等。

- `Observable` 数组并非真正的数组，所以它们无法通过 `Array.isArray()` 的检查。最常见的处理方法是在传递给第三方库之前，你经常需要先对其进行 `.slice()` 操作，从而得到一个浅拷贝的真正数组。

- 向一个已存在的 `observable` 对象中添加属性不会被自动捕获。要么使用 `observable` 映射来替代，要么使用[工具函数](https://cn.mobx.js.org/refguide/object-api.html)中的方法来对想要动态添加属性的对象进行`读/写`迭代。

  ```js
  import { get, set, observable, values } from 'mobx';

  const twitterUrls = observable.object({
    John: 'twitter.com/johnny',
  });

  autorun(() => {
    console.log(get(twitterUrls, 'Sara')); // get 可以追踪尚未存在的属性
  });

  autorun(() => {
    console.log('All urls: ' + values(twitterUrls).join(', '));
  });

  set(twitterUrls, { Sara: 'twitter.com/horsejs' });
  ```

## 差异性

### 设计思想

| 框架  | 思想                                                                                                                                                                     |
| :---- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Redux | `函数式编程`，如`reducer`就是一个`纯函数（pure function）`，接受输入，然后输出结果，除此之外不会有任何影响，也包括不会影响接收的参数；对于相同的输入总是输出相同的结果。 |
| Mobx  | `面向对象编程（OOP）`和 `响应式编程（Reactive Programming）`，将 js 对象包装成`可观察对象`，一旦数据发生变化，就会自动更新。                                             |

### Store 管理方式

| 框架  | 思想                                                             |
| :---- | :--------------------------------------------------------------- |
| Redux | `Redux`中我们习惯于将所有共享的应用数据集中在一个大的`Store`中。 |
| Mobx  | 在`Mbox`则通常按模块将应用状态划分，在多个独立的 store 中管理。  |

### 数据类型差异

| 框架  | 思想                                                                              |
| :---- | :-------------------------------------------------------------------------------- |
| Redux | `Redux`中默认以`JavaScript原生对象`形式存储数据，需要手动追踪所有状态对象的变更。 |
| Mobx  | 在`Mbox`中使用特有的`可观察对象(Observal Object)`，当数据发生变更时自动触发更新。 |

### 数据可变性差异

| 框架  | 思想                                                                                                                                                 |
| :---- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| Redux | `Redux`中对象通常是`不可变的(Immutable)`，我们不能直接操作状态对象，而总是在原来状态对象基础上返回一个新的状态对象，这样就能很方便的返回应用上一状态 |
| Mobx  | 在`Mbox`中推荐使用`Action`进行对应的数据更新操作，但是也允许在非严格模式下直接使用新值去更新状态对象                                                 |

### 使用方式差异

| 框架  | 使用方式                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :---- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Redux | 使用 `Redux` 和 `React` 应用连接时，需要使用 `react-redux` 提供的 `Provider` 和 `connect`。<li style="text-indent:2em;padding: 0.25em 0;">`Provider`:负责将 `Store` 注入 `React` 应用。</li> <li style="text-indent:2em;padding: 0.25em 0;">`connect`:负责将 `store`、`state` 注入容器组件，并选择特定状态作为容器组件`props`传递。</li>                                                                                                                    |
| Mobx  | 使用 `Mobx` 和 `React`应用连接时，需要使用 `mobx-react` 提供的 `Provider` 和 `inject` 以及 `observer`API。<li style="text-indent:2em;padding: 0.25em 0;">`Provider`:负责将 `Stores` 注入 `React` 应用。</li> <li style="text-indent:2em;padding: 0.25em 0;">使用 `inject` 将特定 `store` 注入某组件，`store` 可以传递状态或 `action`；然后使用`observer` 保证组件能响应 `store`中的可观察对象（observable）变更，即 `store` 更新，组件视图响应式更新。</li> |

### 优劣势对比

| 框架  | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| :---- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Redux | <li>数据流流动单一比较清晰，任何 `dispatch` 都会导致广播，需要依据对象引用是否变化来控制更新粒度。</li><li>方便利用时间回溯的特征，可以增强业务的可预测性与错误定位能力(通过中间件可以记录前后的数据差异)。</li><li>时间回溯代价很高，因为每次都要更新引用，除非增加代码复杂度，或使用 `immutable`。</li><li>引入中间件，其实主要为了解决异步带来的副作用，业务逻辑或多或少参杂着 `magic`。但是灵活利用中间件，可以通过约定完成许多复杂的工作。</li> |
| Mobx  | <li>数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但免去了粒度控制烦恼。</li><li>自始至终一份引用，没有时间回溯能力，不需要 `immutable`，也没有复制对象的额外开销。</li> <li>由于没有 `magic`，所以没有中间件机制，没法通过 `magic` 加快工作效率（这里 `magic` 是指 `action` 分发到 `reducer` 的过程）。</li><li>完美支持 `typescript`。</li>                                                                                          |
