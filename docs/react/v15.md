---
title: React 15
nav:
  title: 前端框架
  path: /frontend
  order: 0
group:
  title: 关键版本更新
  path: /react/project/version
---

# React 15

- 2022.04.06

## 架构

React15 架构可以分为两层：

- Reconciler（协调器）—— 负责找出变化的组件
- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

## Reconciler（协调器）

在`React`中可以通过`this.setState`、`this.forceUpdate`、`ReactDOM.render`等 API 触发更新。

每当有更新发生时，`Reconciler`会做如下工作：

1. 调用函数组件、或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM
2. 将虚拟 DOM 和上次更新时的虚拟 DOM 对比
3. 通过对比找出本次更新中变化的虚拟 DOM
4. 通知 Renderer 将变化的虚拟 DOM 渲染到页面上

## Renderer（渲染器）

由于 React 支持跨平台，所以不同平台有不同的`Renderer`。我们前端最熟悉的是负责在浏览器环境渲染的`Renderer` —— `ReactDOM (opens new window)`。

除此之外，还有：

- ReactNative (opens new window)渲染器，渲染 App 原生组件
- ReactTest (opens new window)渲染器，渲染出纯 Js 对象用于测试
- ReactArt (opens new window)渲染器，渲染到 Canvas, SVG 或 VML (IE8)

在每次更新发生时，`Renderer`接到`Reconciler`通知，将变化的组件渲染在当前宿主环境。

## React15 架构的缺点

在`Reconciler`中，`mount`的组件会调用`mountComponent`，`update`的组件会调用`updateComponent`。这两个方法都会递归更新子组件。

由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了 16ms，用户交互就会卡顿。

## 更新的过程

![更新的过程](https://react.iamkasong.com/img/v15.png)

我们可以看到，Reconciler 和 Renderer 是交替工作的，当第一个 li 在页面上已经变化后，第二个 li 再进入 Reconciler。

由于整个过程都是同步的，所以在用户看来所有 DOM 是同时更新的。

假设我们采用异步的方式去更新:

![更新的过程2](https://react.iamkasong.com/img/dist.png)

当第一个 li 完成更新时中断更新，即步骤 3 完成后中断更新，此时后面的步骤都还未执行。

用户本来期望 123 变为 246。实际却看见更新不完全的 DOM！（即 223）

基于这个原因，React 决定重写整个架构。
