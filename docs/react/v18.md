---
title: React 18
nav:
  title: 前端框架
  path: /frontend
  order: 0
group:
  title: 关键版本更新
  path: /react/project/version
---

# React 18

- 2022.01.13

## 概述

React 18 增加了一个新的优化特性，在代码中无需手动处理，就可以支持更多场景下的`批量更新 (batching)`。

## 批量更新

> 批量更新是指 `React` 会将多次 `state` 更新进行合并处理，最终只进行一次渲染，以获得更好的性能。

例如我们在某个点击事件里面处理了 2 个状态的更新，React 总是会把它们批量处理成一个重新渲染。

- 示例：React 16 中事件处理函数中的批量更新

  ```jsx
  import React, { useState, useLayoutEffect } from 'react';

  function App() {
    const [count, setCount] = useState(0);
    const [flag, setFlag] = useState(false);

    function handleClick() {
      setCount((c) => c + 1); // Does not re-render yet
      setFlag((f) => !f); // Does not re-render yet
      // React will only re-render once at the end (that's batching!)
    }

    useLayoutEffect(() => {
      console.log('demo1: 当前React版本是^16.12.0，该版本下仅会输出一次日志');
    });

    return (
      <div>
        <button onClick={handleClick}>Next</button>
        <h1 style={{ color: flag ? 'blue' : 'black' }}>{count}</h1>
      </div>
    );
  }

  export default App;
  ```

批量更新可以提高组件的渲染性能，因为它避免了不必要的渲染。同时，也防止了组件中只更新一个状态变量，导致组件其他状态变化并未完全渲染出来，这可能会引起 bug。

**然而，`React` 的批量更新并不是所有场景都会生效**。例如，如果在 `handleClick` 中请求数据，然后在数据请求成功之后更新状态，那么 `React` 不会触发批量更新，而是执行`两次`独立的更新。

这是因为，之前版本的 `React` 要求只有在**浏览器事件（如点击事件）**中才会触发批量更新。

但是，在下面的代码示例中，当数据请求成功之后，点击事件早已经结束了，这时进行状态更新（在 fetch 回调函数中）是不会触发批量更新的。

- 示例：React 16 不会批处理外部事件处理函数

  ```jsx
  import React, { useState, useLayoutEffect } from 'react';

  function App() {
    const [count, setCount] = useState(0);
    const [flag, setFlag] = useState(false);

    function fetchSomething() {
      return new Promise((resolve) => setTimeout(resolve, 100));
    }
    function handleClick() {
      fetchSomething().then(() => {
        // React 17 and earlier does NOT batch these because
        // they run *after* the event in a callback, not *during* it
        setCount((c) => c + 1); // Causes a re-render
        setFlag((f) => !f); // Causes a re-render
      });
    }

    useLayoutEffect(() => {
      console.log(
        'demo2: 当前React版本是^16.12.0，在外部事件处理函数中该版本下会输出二次日志',
      );
    });

    return (
      <div>
        <button onClick={handleClick}>Next</button>
        <h1 style={{ color: flag ? 'blue' : 'black' }}>{count}</h1>
      </div>
    );
  }

  export default App;
  ```

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Info } from 'interview';

const txt =
  '\n在 React 18 之前，只会在 `React 事件处理函数中`执行过程中进行批量更新。在默认情况下，对 `promises`、`setTimeout`、`原生事件处理函数`或`其他任何事件中`的状态更新都不会进行批量更新。';

export default () => <Info txt={txt} />;
```

## 新特性

### 自动批量更新(Automatic batching)

从 React 18 的 `createRoot` 开始，不论在哪里， 所有更新都将自动进行批量更新。

这意味着 `setTimeout`、`promises`、`原生事件处理函数`或其他任何事件的批量更新都将与 `React` 事件一样，以相同的方式进行批量更新。我们希望这样可以减少渲染工作量，从而提高应用程序的性能:

[在 React 18 使用 createRoot 对外部事件处理程序进行批量处理](https://codesandbox.io/s/morning-sun-lgz88?file=/src/index.js)

#### 如果在某些场景我们不想批量更新怎么办？

通常批处理是安全的，但有些代码可能依赖于在状态更改后立即从 DOM 中读取某些内容。 对于这种情况，可以使用 `ReactDOM.flushSync()` 选择不进行批量处理：

```js
import { flushSync } from 'react-dom'; // Note: react-dom, not react

function handleClick() {
  flushSync(() => {
    setCounter((c) => c + 1);
  });
  // React has updated the DOM by now
  flushSync(() => {
    setFlag((f) => !f);
  });
  // React has updated the DOM by now
}
```

### startTransition

官方工作小组里面的讨论描述了一个场景，一个输入框，接收用户输入，然后去筛选列表项，场景很常见，但是会有一个性能隐患，输入这个操作可能会触发大量的更新，导致页面卡顿，给用户直观的感受就是输入框有点卡，不能实时显示输入的字符了，那么要怎么办呢?

这让我想到了 react 的`并发渲染模式`，不就是要来解决这种优先级的问题么，但是遗憾的是一直处于实验当中，还不能安心用在工作中，不扯远了，还是回到这个 api 上来，通过代码我们对比一下：

```js
// 优先级高 实时显示
setInputValue(input);

// 优先级不高 显示搜索结果
setSearchQuery(input);
```

上述代码是我们的常用写法，用户输入就更新输入框的状态值进行实时显示输入，然后去筛选列表，`setInputValue` 和 `setSearchQuery` 是同时执行的。

```js
import { startTransition } from 'react';

// Urgent: Show what was typed
setInputValue(input);

// Mark any state updates inside as transitions
startTransition(() => {
  // Transition: Show the results
  setSearchQuery(input);
});
```

上述代码使用了 `startTransition` 这个`api`，将`setSearchQuery`包裹其中，实现手动的渲染任务优先级排列，那么此时 `setInputValue` 的更新就高于`setSearchQuery`，因此用户的输入响应就能得到保证，从而实现丝滑的体验。

### New Suspense SSR Architecture

react18 对 `SSR` 的性能进行了新的改进，引入了`pipeToNodeWritable`这个新的 API，这个 API 可以替换`renderToString`，同时`renderToNodeStream`被标记为`Deprecated`，为什么会有这些改动呢，官方给出了解释：

- `renderToString`: Keeps working (with limited Suspense support).
- `renderToNodeStream`: Deprecated (with full Suspense support, but without streaming).
- `pipeToNodeWritable`: New and recommended (with full Suspense support and streaming)

出现了两个需要注意的单词：`Suspense` 和 `streaming`。

`Suspense`这个组件在`16.6.0`被正式提出来，以前主要配合`React.lazy`用来异步加载组件的，而`streaming`就是指的`React Server Components`，现在 react18 对这两者的支持就更加完善了，因此`react18`的`SSR`将让用户更快的看见界面，更早的交互。

我们来看下传统的 SSR 流程吧：

1. On the server, fetch data for the entire app.
2. Then, on the server, render the entire app to HTML and send it in the response.
3. Then, on the client, load the JavaScript code for the entire app.
4. Then, on the client, connect the JavaScript logic to the server-generated HTML for the entire app (this is “hydration”).

以上四步必须严格按照流程一步步来，就像`waterfall`一样，如果其中哪一步慢了，就会阻塞后面的流程，这样用户就需要忍受更长的白屏时间，因此如果将上面四个步骤打散成一个个小的任务单元，那么先完成的任务就可以尽快呈现到用户面前，这样体验自然就更优了。

这也是`react18`对`Suspense`和`streaming`改进的动力所在，dan 对这一部分有详细的介绍，点[这里](https://github.com/reactwg/react-18/discussions/37)了解更多。

## 万物皆可 Suspense

对于 React 来说，有两类瓶颈需要解决：

1. CPU 的瓶颈，如大计算量的操作导致页面卡顿
2. IO 的瓶颈，如请求服务端数据时的等待时间

其中 CPU 的瓶颈通过并发特性的优先级中断机制解决。

IO 的瓶颈则交给`Suspense`解决。

所以，未来一切与 IO 相关的操作，都会收敛到`Suspense`这一解决方案内。

从最初的`React.lazy`到如今仍在开发中的`Server Components`，最终万物皆可`Suspense`。

这其中有些逻辑是很复杂的，比如：

- Server Components
- 新的服务端渲染方案

所以，这些操作不大可能是直接面向开发者的。

这些操作会交由各种库实现。如果复杂度更高，则会交由基于`React`封装的框架实现，比如`Next.js`、`Remix`。

这也是为什么 React 团队核心人物`Sebastian`会加入`Next.js`。

可以说，`React`未来的定位是：一个前端底层操作系统，足够复杂，一般开发者慎用。

而开发者使用的是基于该操作系统实现的各种上层应用。

## 新 API

### useSyncExternalStore

`useSyncExternalStore` 经历了一次修改，由 `unstable_useMutableSource` 改变而来，用于订阅外部数据源。主要帮助有外部 `store` 需求的开发者解决撕裂问题。

一个监听 `innerWidth` 变化的 hook 最简单例子：

```js
import { useMemo, useSyncExternalStore } from 'react';

function useInnerWidth(): number {
  // 保持 subscribe 固定引用，避免 resize 监听器重复执行
  const [subscribe, getSnapshot] = useMemo(() => {
    return [
      (notify: () => void) => {
        // 真实情况这里会用到节流
        window.addEventListener('resize', notify);
        return () => {
          window.removeEventListener('resize', notify);
        };
      },
      // 返回 resize 后需要的快照
      () => window.innerWidth,
    ];
  }, []);
  return useSyncExternalStore(subscribe, getSnapshot);
}

function WindowInnerWidthExample() {
  const width = useInnerWidth();

  return <p>宽度: {width}</p>;
}
```

`React` 自身 `state` 已经原生的解决的并发特性下的撕裂(tear) 问题。`useSyncExternalStore` 主要对于框架开发者，比如 `redux`，它在控制状态时可能并非直接使用的 `React` 的 `state`，而是自己在外部维护了一个 `store` 对象，脱离了 `React` 的管理，也就无法依靠 `React` 自动解决撕裂问题。因此 `React` 对外提供了这样一个 `API`。

目前 `React-Redux 8.0` 已经基于 `useSyncExternalStore` 实现。

### useInsertionEffect

`useInsertionEffect` 的工作原理大致 `useLayoutEffect` 相同，只是此时无法访问 DOM 节点的引用。

因此推荐的解决方案是使用这个 `Hook` 来插入样式表（或者如果你需要删除它们，可以引用它们）：

```js
function useCSS(rule) {
  useInsertionEffect(() => {
    if (!isInserted.has(rule)) {
      isInserted.add(rule);
      document.head.appendChild(getStyleForRule(rule));
    }
  });
  return rule;
}
function Component() {
  let className = useCSS(rule);
  return <div className={className} />;
}
```

### useId

`useId` 是一个 API，用于在客户端和服务器上生成唯一 ID。使用示例：

```js
function Checkbox() {
  const id = useId();
  return (
    <div>
      <label htmlFor={id}>选择框</label>
      <input type="checkbox" name="sex" id={id} />
    </div>
  );
}
```

### useDeferredValue

返回一个延迟响应的值，这通常用于在具有基于用户输入立即渲染的内容，以及需要等待数据获取的内容时，保持接口的可响应性。

```js
import { useDeferredValue } from 'react';

const deferredValue = useDeferredValue(value);
```
