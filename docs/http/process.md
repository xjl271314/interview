---
title: 进程与线程
nav:
  title: http
  path: /http
group:
  title: http相关
  path: /http/project/base
---

# 进程与线程

- 2022.10.26

## 进程与线程的区别?

- `进程(process)`: 是程序的一次执行过程,是一个动态概念,是程序在执行过程中分配和管理资源的基本单位。

- `线程(thread)`: 是 CPU 调度和分配的基本单位,它可以与同属于一个进程的其他线程共享该进程所拥有的全部资源。

浏览器属于一个应用程序,而应用程序的一次执行，可以理解为计算机启动了一个进程,进程启动后,CPU 会给该进程分配相应的内存空间,当我们的进程得到了内存之后,就可以使用线程进行资源的调度,进而完成我们应用程序的功能。

## 进程与线程的组成?

```jsx
import React from 'react';
import { Space } from 'antd';

export default () => {
  return (
    <Space>
      <img
        src="https://img-blog.csdnimg.cn/4c06e2c1a7854465b340e9c6b384785c.png"
        alt="进程的组成"
        style={{ width: '100%' }}
      />
      <img
        src="https://img-blog.csdnimg.cn/edeab0eafaa3494da6a22d8cdf85def8.png"
        alt="线程的组成"
        style={{ width: '100%' }}
      />
    </Space>
  );
};
```

- 内存：这里的内存是`逻辑内存`。指的是内存的`寻址空间`。
- 文件/网络句柄：它们是所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的。
- 栈：我们从主线程的入口 main 函数，会不断的进行函数调用，每次调用的时候，会把所有的参数和返回地址压入到栈中。
- PC：Program Counter 程序计数器，操作系统真正运行的是一个个的线程， 而我们的进程只是它的一个容器。PC 就是指向当前的指令，而这个指令是放在内存中。 每个线程都有一串自己的指针，去指向自己当前所在内存的指针。
- 缓冲区溢出：例如：我们有个地方要输入用户名，本来是用来存数据的地方。然后黑客把数据输入的特别长。这个长度超出了我们给数据存储的内存区，这时候跑到了我们给程序分配的一部分内存中。黑客就可以通过这种办法将他所要运行的代码写入到用户名框中，来植入进来。我们的解决方法就是，用户名的长度限制不要超过用户名的缓冲区的大小。
- TLS：Thread Local Storage，我们知道每个进程都有自己独立的内存，这时候我们想，我们的线程有没有一块独立的内存呢？答案就是 TLS。

## 进程之间是如何通信的?

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为`进程间通信（IPC，InterProcess Communication）`

### 进程之间通信的方式有哪些?

1. 管道/匿名管道(pipe)

   - 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
   - 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);
   - 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
   - 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

   **管道的实质：**

   管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。

   该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。

   当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

   **管道的局限：**

   管道的主要局限性正体现在它的特点上：

   1. 只支持单向数据流；
   2. 只能用于具有亲缘关系的进程之间；
   3. 没有名字；
   4. 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
   5. 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等

2. 有名管道(FIFO)

   匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。

   有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。

   值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。

   **匿名管道和有名管道总结：**

   1. 管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。

   2. 匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

   3. 无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。

   4. 有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。

3. 信号(Signal)

   - 信号是 Linux 系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
   - 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
   - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

   **Linux 系统中常用信号：**

   | 信号              | 描述                                                                                       |
   | :---------------- | :----------------------------------------------------------------------------------------- |
   | SIGHUP            | 用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。     |
   | SIGINT            | 程序终止信号。程序运行过程中，按 `Ctrl+C` 键将产生该信号。                                 |
   | SIGQUIT           | 程序退出信号。程序运行过程中，按 `Ctrl+\\` 键将产生该信号。                                |
   | SIGBUS 和 SIGSEGV | 进程访问非法地址。                                                                         |
   | SIGFPE            | 运算中出现致命错误，如除零操作、数据溢出等。                                               |
   | SIGKILL           | 用户终止进程执行信号。shell 下执行 `kill -9` 发送该信号。                                  |
   | SIGTERM           | 结束进程信号。shell 下执行 `kill 进程pid` 发送该信号。                                     |
   | SIGALRM           | 定时器信号。                                                                               |
   | SIGCLD            | 子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。 |

   **信号来源：**

   信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：

   - 硬件来源：用户按键输入 Ctrl+C 退出、硬件异常如无效的存储访问等。
   - 软件终止：终止进程信号、其他进程调用 kill 函数、软件异常产生信号。

   **信号生命周期和处理流程：**

   信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的 pid），然后传递给操作系统；

   操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号

   目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前 CPU 的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。

4. 消息(Message)队列

   - 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
   - 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
   - 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

   **消息队列特点总结：**

   1. 消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.
   2. 消息队列允许一个或多个进程向它写入与读取消息.
   3. 管道和消息队列的通信数据都是先进先出的原则。
   4. 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。
   5. 消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
   6. 目前主要有两种类型的消息队列：POSIX 消息队列以及 System V 消息队列，系统 V 消息队列目前被大量使用。系统 V 消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。

5. 共享内存(share memory)

   使得多个进程可以可以直接读写同一块内存空间，是最快的可用 IPC 形式。是针对其他通信机制运行效率较低而设计的。

   为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。

   由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

   **Linux 支持的主要三种共享内存方式：`mmap()系统调用`、`Posix共享内存`，以及`System V共享内存实践`**

6. 信号量(semaphore)

   信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
   为了获得共享资源，进程需要执行下列操作：

   1. 创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是 1，也可是 0。
   2. 等待一个信号量：该操作会测试这个信号量的值，如果小于 0，就阻塞。也称为 P 操作。
   3. 挂出一个信号量：该操作将信号量的值加 1，也称为 V 操作。

   为了正确地实现信号量，信号量值的测试及减 1 操作应当是原子操作。为此，信号量通常是在内核中实现的。

   Linux 环境中，有三种类型：`Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）`、`Posix基于内存的信号量（存放在共享内存区中）`、`System V信号量（在内核中维护）`。这三种信号量都可用于进程间或线程间的同步。

7. 套接字(socket)

   套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

## 线程之间是如何通信的?

线程的通信就比较简单，有一大块共享的内存，只要大家的指针是同一个就可以看到各自的内存。

## 进程的调度算法有哪些?

1. 先来先服务调度算法

   先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。

   在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

2. 短作业(进程)优先调度算法

   短作业(进程)优先调度算法 SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。

3. 高优先权优先调度算法

   为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。

   此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。

   1. `非抢占式优先权算法`：在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。

   2. `抢占式优先权调度算法`：在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程 i 时，就将其优先权 Pi 与正在执行的进程 j 的优先权 Pj 进行比较。如果 Pi≤Pj，原进程 Pj 便继续执行；但如果是 Pi>Pj，则立即停止 Pj 的执行，做进程切换，使 i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。

   容易出现优先级倒置现象:优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的 CPU 时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得 CPU 时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺 CPU 时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。

   **优先级倒置解决方案：**

   - 设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。
   - 优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统 VxWorks 就是采用这种策略。
   - 第三种方法就是临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。火星探路者正是由于在临界区中运行的气象任务被中断发生的通信任务所抢占才导致故障，如果有临界区的禁止中断保护，此一问题也不会发生。

4. 高响应比优先调度算法:

   在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：

   $$R_p = \frac{等待时间+要求服务时间}{要求服务时间} = \frac{响应时间}{要求服务时间}$$

   在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。

5. 时间片轮转法

   在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。

6. 多级反馈队列调度算法

   前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述:

   1. 设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。

   2. 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。

   3. 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1 ～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1 ～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。

## 批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？

### 批处理系统常用调度算法：

- 先来先服务：FCFS
- 最短作业优先
- 最短剩余时间优先
- 响应比最高者优先

### 分时系统调度算法：

- 轮转调度
- 优先级调度
- 多级队列调度
- 彩票调度

### 实时系统调度算法：

- 单比率调度
- 限期调度
- 最少裕度法
