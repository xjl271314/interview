---
title: 垃圾回收机制(V8引擎))
nav:
  title: javascript
  path: /javascript
  order: 0
group:
  title: javascript相关试题
  path: /javascript/project
---

# javascript 中的垃圾回收机制和 V8 引擎是怎么工作的?

- 2021.06.09

## 垃圾回收机制

`JavaScript` 具有`自动垃圾收集机制`，也就是说，执行环境会负责管理代码执行过程中使用的内存。

这种垃圾收集机制的原理其实很简单:

> 找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性地执行这一操作。

## 垃圾回收机制分类

常用的垃圾回收机制主要有以下两种方式:

1. 标记清除(mark-and-sweep).

2. 引用计数(reference counting).

### 标记清除(mark-and-sweep)

> 当变量进入环境(例如，在函数中声明一个变量)时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

`JavaScript`中最常用的垃圾收集方式是`标记清除`。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上`标记`。

然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 引用计数

> 引用计数的含义是跟踪记录每个值被引用的次数。

当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。

当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。

```js
function problem() {
  var objectA = new Object();
  var objectB = new Object();
  objectA.someOtherObject = objectB;
  objectB.anotherObject = objectA;
}
```

在这个例子中，`objectA` 和 `objectB` 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 `2`。

在采用`标记清除策略`的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种`相互引用`不是个问题。

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Info } from 'interview';

const txt =
  '但在采用引用计数策略的实现中，当函数执行完毕后，`objectA` 和 `objectB` 还将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。';

export default () => <Info type="warning" txt={txt} />;
```

## 什么是 V8 引擎?

> `V8` 是 `JavaScript 虚拟机`的一种。我们可以简单地把 `JavaScript 虚拟机`理解成是一个`翻译程序`，将人类能够理解的编程语言 `JavaScript`，翻译成机器能够理解的机器语言。如下图所示：

![V8引擎示例](https://img-blog.csdnimg.cn/20210609113936941.png)

上图中，中间的`黑盒`就是 `JavaScript 引擎 V8`。目前市面上有很多种 `JavaScript 引擎`，诸如 `SpiderMonkey`、`V8`、`JavaScriptCore` 等。

而由谷歌开发的开源项目 `V8` 是当下使用最广泛的 `JavaScript 虚拟机`，全球有超过 25 亿台安卓设备，而这些设备中都使用了 `Chrome 浏览器`，所以我们写的 `JavaScript` 应用，大都跑在 `V8` 上。

### V8 发展史

在 `V8` 出现之前，所有的 `JavaScript 虚拟机`所采用的都是`解释执行`的方式，这是 `JavaScript` 执行速度过慢的一个主要原因。

而 `V8` 率先引入了`即时编译（JIT）`的`双轮驱动`的设计，这是一种`权衡策略`，`混合编译执行`和`解释执行`这两种手段，给 `JavaScript` 的执行速度带来了极大的提升。

`V8` 出现之后，各大厂商也都在自己的 `JavaScript 虚拟机`中引入了 `JIT 机制`，所以你会看到目前市面上 `JavaScript 虚拟机`都有着类似的架构。另外，`V8` 也是早于其他虚拟机引入了`惰性编译`、`内联缓存`、`隐藏类`等机制，进一步优化了 `JavaScript` 代码的编译执行效率。

可以说，V8 的出现，将 `JavaScript` 虚拟机技术推向了一个全新的高度。

### V8 编译流水线

`V8` 内部 执行 `JavaScript` 代码的流程是怎么样的呢?我们把这套流程称之为 `V8` 的`编译流水线`，其完整流程如下图所示：

![V8编译流水线](https://img-blog.csdnimg.cn/20210609115511493.png)

`编译流水线`本身并不复杂，但是其中涉及到了很多技术，诸如 `JIT`、`延迟解析`、`隐藏类`、`内联缓存`等等。这些技术决定着一段 `JavaScript` 代码能否正常执行，以及代码的执行效率。

比如 `V8` 中使用的`隐藏类（Hide Class）`，这是将 `JavaScript` 中`动态类型`转换为`静态类型`的一种技术，可以消除动态类型的语言执行速度过慢的问题，如果你熟悉 `V8` 的工作机制，在你编写 `JavaScript` 时，就能充分利用好隐藏类这种强大的优化特性，写出更加高效的代码。

再比如，V8 实现了 `JavaScript` 代码的`惰性解析`，目的是为了加速代码的启动速度，通过对惰性解析机制的学习，你可以优化你的代码更加适应这个机制，从而提高程序性能。

要想充分了解 `V8` 是怎么工作的，除了要分析编译流水线，我们还需要了解另外两个非常重要的特性，那就是事件循环系统和垃圾回收机制。

`事件循环系统`这块在之前有提到过，这里主要关注`垃圾回收机制`。

`V8` 在执行垃圾回收时，会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，这也是我们经常会遇到的一个问题。我们需要知道 `V8` 是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完整的系统，当下次遇到内存问题时，就知道如何去排查了。

### V8 的内存限制

`V8` 引擎帮助我们实现了自动的垃圾回收管理，解放了我们勤劳的双手，但 `V8` 引擎中的内存使用也并不是无限制的。

默认情况下，`V8` 引擎在 `64` 位系统下最多只能使用约 `1.4GB` 的内存，在 `32` 位系统下最多只能使用约 `0.7GB` 的内存，在这样的限制下，必然会导致在 `node` 中无法直接操作大内存对象，比如将一个 `2GB` 大小的文件全部读入内存进行字符串分析处理，即使物理内存高达 `32GB` 也无法充分利用计算机的内存资源，那么为什么会有这种限制呢？

这个要回到 `V8` 引擎的设计之初，起初只是作为浏览器端 `JavaScript` 的执行环境，在浏览器端我们其实很少会遇到使用大量内存的场景，因此也就没有必要将最大内存设置得过高。但这只是一方面，其实还有另外两个主要的原因：

1. `JS单线程机制`：

   > 作为浏览器的脚本语言，JS 的主要用途是与用户交互以及操作 DOM，那么这也决定了其作为单线程的本质，单线程意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务。

   试想如果 `JS` 是多线程的，一个线程在删除 `DOM` 元素的同时，另一个线程对该元素进行修改操作，那么必然会导致复杂的同步问题。

   既然 `JS` 是单线程的，那么也就意味着在 `V8` 执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行 `JS` 逻辑。

   因此，由于 `JS` 的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。

   ```jsx
   /**
    * inline: true
    */
   import React from 'react';
   import { Info } from 'interview';

   const txt =
     '虽然`JS`是单线程的，但是为了能够充分利用操作系统的`多核CPU`计算能力，在`HTML5`中引入了新的`Web Worker标准`，其作用就是<strong>为JS创造多线程环境</strong>，允许主线程创建`Worker`线程，将一些任务分配给后者运行。\n\n在主线程运行的同时，`Worker`在后台运行，两者互不干扰。等到`Worker`线程完成计算任务，再把结果返回给主线程。这样的好处是， 一些计算密集型或高延迟的任务，被`Worker`线程负担，主线程(通常负责UI交互)就会很流畅，不会被阻塞或者拖慢。\n\n`Web Worker`不是JS的一部分，而是通过JS访问的浏览器特性，其虽然创造了一个多线程的执行环境，但是子线程完全受主线程控制，不能访问浏览器特定的`API`，例如`操作DOM`，因此这个新标准并没有改变`JS单线程`的本质。';

   export default () => <Info type="info" txt={txt} />;
   ```

2. `垃圾回收机制`:

   垃圾回收本身也是一件非常耗时的操作，假设 `V8` 的堆内存为 `1.5G`，那么 `V8` 做一次小的垃圾回收需要 `50ms` 以上，而做一次`非增量式回收`甚至需要 `1s` 以上，可见其耗时之久。

   而在这 1s 的时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，如果有动画正在运行，也会造成动画卡顿掉帧的情况，严重影响应用程序的性能。

   因此如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，浏览器也就越长时间得不到响应。

基于以上两点，`V8` 引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接`限制堆内存`的大小，毕竟在浏览器端一般也不会遇到需要操作几个 `G` 内存这样的场景。

但是在 `node` 端，涉及到的 `I/O 操作`可能会比浏览器端更加复杂多样，因此更有可能出现内存溢出的情况。不过也没关系，`V8` 为我们提供了可配置项来让我们手动地调整内存大小，但是需要在 `node` 初始化的时候进行配置，我们可以通过如下方式来手动设置。

```js
node --v8-options
```

在控制台中我们可以看到大量的 V8 引擎相关的配置信息。

![V8配置片段](https://img-blog.csdnimg.cn/20210609215436465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hqbDI3MTMxNA==,size_16,color_FFFFFF,t_70)

```js
// 设置新生代内存中单个半空间的内存最小值，单位MB
node --min-semi-space-size=1024 xxx.js

// 设置新生代内存中单个半空间的内存最大值，单位MB
node --max-semi-space-size=1024 xxx.js

// 设置老生代内存最大值，单位MB
node --max-old-space-size=2048 xxx.js
```

通过以上方法便可以手动放宽 `V8` 引擎所使用的内存限制，同时 `node` 也为我们提供了 `process.memoryUsage()`方法来让我们可以查看当前 `node 进程`所占用的实际内存大小。

```js
process.memoryUsage();
```

![process.memoryUsage()](https://img-blog.csdnimg.cn/2021060921580893.png)

在上图中，包含的几个字段的含义分别如下所示，单位均为`字节`：

- `heapTotal`：表示 V8 当前申请到的堆内存总大小。
- `heapUsed`：表示当前内存使用量。
- `external`：表示 V8 内部的 C++对象所占用的内存。
- `rss(resident set size)`：表示驻留集大小，是给这个 `node` 进程分配了多少物理内存，这些物理内存中包含堆，栈和代码片段。对象，闭包等存于堆内存，变量存于栈内存，实际的 `JavaScript` 源代码存于代码段内存。使用 `Worker` 线程时，`rss` 将会是一个对整个进程有效的值，而其他字段则只针对当前线程。

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Info } from 'interview';

const txt =
  '在 `JS` 中声明对象时，该对象的内存就分配在堆中，如果当前已申请的堆内存已经不够分配新的对象，则会继续申请堆内存直到堆的大小超过 `V8` 的限制为止。';

export default () => <Info type="info" txt={txt} />;
```

## V8 垃圾回收策略?

> `V8` 的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。

### V8 的内存结构

在 `V8` 引擎的堆结构组成中，其实除了`新生代`和`老生代`外，还包含其他几个部分，但是`垃圾回收`的过程主要出现在`新生代`和`老生代`，所以对于其他的部分我们没必要做太多的深入，有兴趣的小伙伴儿可以查阅下相关资料，`V8` 的内存结构主要由以下几个部分组成：

- `新生代(new_space)`：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。

- `老生代(old_space)`：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为老生代指针区和老生代数据区，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。

- `大对象区(large_object_space)`：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。

- `代码区(code_space)`：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。

- `map区(map_space)`：存放`Cell`和`Map`，每个区域都是存放相同大小的元素，结构简单(这里没有做具体深入的了解，有清楚的小伙伴儿还麻烦解释下)。

内存结构图如下所示：

![V8内存结构图](https://img-blog.csdnimg.cn/20210609221052952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hqbDI3MTMxNA==,size_16,color_FFFFFF,t_70)

上图中的带斜纹的区域代表暂未使用的内存，`新生代(new_space)`被划分为了两个部分，其中一部分叫做 `inactive new space`，表示暂未激活的内存区域，另一部分为激活状态。

### 新生代

在 `V8` 引擎的内存结构中，`新生代`主要用于存放存活时间较短的对象。新生代内存是由两个 `semispace(半空间)`构成的，内存最大值在 `64` 位系统和 `32` 位系统上分别为 `32MB` 和 `16MB`，在新生代的垃圾回收过程中主要采用了 `Scavenge` 算法。

`Scavenge` 算法是一种典型的`牺牲空间换取时间`的算法，对于`老生代内存`来说，可能会存储大量对象，如果在`老生代`中使用这种算法，势必会造成内存资源的浪费，但是在`新生代内存`中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。

> 在 `Scavenge` 算法的具体实现中，主要采用了 `Cheney` 算法，它将新生代内存一分为二，每一个部分的空间称为 `semispace`，也就是我们在上图中看见的 `new_space` 中划分的两个区域，其中处于`激活状态`的区域我们称为 `From 空间`，`未激活(inactive new space)`的区域我们称为 `To` 空间。

这两个空间中，始终只有一个处于`使用状态`，另一个处于`闲置状态`。我们的程序中声明的对象首先会被分配到 `From` 空间，当进行垃圾回收时，如果 `From` 空间中尚有存活对象，则会被复制到 `To` 空间进行保存，非存活的对象会被自动回收。

当复制完成后，`From 空间`和 `To 空间`完成一次角色互换，`To` 空间会变为新的 `From` 空间，原来的 `From` 空间则变为 `To` 空间。

基于以上算法，我们可以画出如下的流程图：

- 假设我们在 From 空间中分配了三个对象 A、B、C

  ![步骤一](https://img-blog.csdnimg.cn/20210609221541336.png)

- 当程序主线程任务第一次执行完毕后进入垃圾回收时，发现对象 A 已经没有其他引用，则表示可以对其进行回收

  ![步骤二](https://img-blog.csdnimg.cn/20210609222146173.png)

- 对象 B 和对象 C 此时依旧处于活跃状态，因此会被复制到 To 空间中进行保存

  ![步骤三](https://img-blog.csdnimg.cn/20210609222227411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hqbDI3MTMxNA==,size_16,color_FFFFFF,t_70)

- 接下来将 From 空间中的所有非存活对象全部清除

  ![步骤四](https://img-blog.csdnimg.cn/20210609222310752.png)

- 此时 From 空间中的内存已经清空，开始和 To 空间完成一次角色互换

  ![步骤五](https://img-blog.csdnimg.cn/20210609222342508.png)

- 当程序主线程在执行第二个任务时，在 From 空间中分配了一个新对象 D

  ![步骤六](https://img-blog.csdnimg.cn/2021060922240725.png)

- 任务执行完毕后再次进入垃圾回收，发现对象 D 已经没有其他引用，表示可以对其进行回收

  ![步骤七](https://img-blog.csdnimg.cn/2021060922242942.png)

- 对象 B 和对象 C 此时依旧处于活跃状态，再次被复制到 To 空间中进行保存

  ![步骤八](https://img-blog.csdnimg.cn/20210609222450844.png)

- 再次将 From 空间中的所有非存活对象全部清除

  ![步骤九](https://img-blog.csdnimg.cn/2021060922251175.png)

- From 空间和 To 空间继续完成一次角色互换

  ![步骤十](https://img-blog.csdnimg.cn/20210609222534754.png)

通过以上的流程图，我们可以很清楚地看到，`Scavenge` 算法的垃圾回收过程主要就是将存活对象在 `From` 空间和 `To` 空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制。

### 对象晋升

> 当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从`新生代转移到老生代的过程我们称之为晋升`。

对象晋升的条件主要有以下两个：

1. 对象是否经历过一次`Scavenge`算法

2. `To`空间的内存占比是否已经超过`25%`

默认情况下，我们创建的对象都会分配在 From 空间中，当进行垃圾回收时，在将对象从 From 空间复制到 To 空间之前，会先检查该对象的内存地址来判断是否已经经历过一次 Scavenge 算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到 To 空间，可以用以下的流程图来表示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021060922294482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hqbDI3MTMxNA==,size_16,color_FFFFFF,t_70)

如果对象没有经历过 `Scavenge` 算法，会被复制到 `To` 空间，但是如果此时 `To` 空间的内存占比已经超过 `25%`，则该对象依旧会被转移到老生代，如下图所示:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210609223202689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hqbDI3MTMxNA==,size_16,color_FFFFFF,t_70)

之所以有 `25%`的内存限制是因为 `To` 空间在经历过一次 `Scavenge` 算法后会和 `From` 空间完成角色互换，会变为 `From` 空间，后续的内存分配都是在 `From` 空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。

### 老生代

在老生代中，因为管理着大量的存活对象，如果依旧使用 `Scavenge` 算法的话，很明显会浪费一半的内存，因此已经不再使用 `Scavenge` 算法，而是采用新的算法 `Mark-Sweep(标记清除)`和 `Mark-Compact(标记整理)`来进行管理。

这里就是我们上述说道的`引用计数`,我们再来回顾一下:

```js
// 创建了两个对象obj1和obj2，其中obj2作为obj1的属性被obj1引用，因此不会被垃圾回收
let obj1 = {
  obj2: {
    a: 1,
  },
};

// 创建obj3并将obj1赋值给obj3，让两个对象指向同一个内存地址
let obj3 = obj1;

// 将obj1重新赋值，此时原来obj1指向的对象现在只由obj3来表示
obj1 = null;

// 创建obj4并将obj3.obj2赋值给obj4
// 此时obj2所指向的对象有两个引用：一个是作为obj3的属性，另一个是变量obj4
let obj4 = obj3.obj2;

// 将obj3重新赋值，此时本可以对obj3指向的对象进行回收，但是因为obj3.obj2被obj4所引用，因此依旧不能被回收
obj3 = null;

// 此时obj3.obj2已经没有指向它的引用，因此obj3指向的对象在此时可以被回收
obj4 = null;
```

上述例子在经过一系列操作后最终对象会被垃圾回收，但是一旦我们碰到`循环引用`的场景，就会出现问题，我们看下面的例子：

```js
function foo() {
  let a = {};
  let b = {};
  a.a1 = b;
  b.b1 = a;
}
foo();
```

这个例子中我们将对象 `a` 的 `a1` 属性指向对象 `b`，将对象 `b` 的 `b1` 属性指向对象 `a`，形成两个对象`相互引用`，在 `foo` 函数执行完毕后，函数的作用域已经被销毁，作用域中包含的变量 `a` 和 `b` 本应该可以被回收，但是因为采用了`引用计数`的算法，两个变量均存在指向自身的引用，因此依旧无法被回收，导致内存泄漏。

因此为了`避免循环引用导致`的内存泄漏问题，截至 2012 年所有的现代浏览器均放弃了这种算法，转而采用新的`Mark-Sweep(标记清除)`和`Mark-Compact(标记整理)`算法。在上面循环引用的例子中，因为变量 `a` 和变量 `b` 无法从 `window` 全局对象访问到，因此无法对其进行标记，所以最终会被回收。

`Mark-Sweep(标记清除)`分为`标记`和`清除`两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。`Mark-Sweep` 算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：

- 垃圾回收器会在内部构建一个根列表，用于从根节点出发去寻找那些可以被访问到的变量。比如在 JavaScript 中，window 全局对象可以看成一个根节点。

- 然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。

- 最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。

#### 以下几种情况都可以作为根节点：

- 全局对象
- 本地函数的局部变量和参数
- 当前嵌套调用链上的其他函数的变量和参数

![根节点](https://user-gold-cdn.xitu.io/2019/12/8/16ee468e85a1084d?imageslim)

但是 `Mark-Sweep` 算法存在一个问题，就是在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。

为了解决这种内存碎片的问题，`Mark-Compact(标记整理)`算法被提了出来，该算法主要就是用来解决`内存的碎片化问题的`，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，我们可以用如下流程图来表示:

- 假设在老生代中有 A、B、C、D 四个对象
  ![步骤一](https://img-blog.csdnimg.cn/2021060922485188.png)

- 在垃圾回收的`标记阶段`，将对象 A 和对象 C 标记为活动的
  ![步骤二](https://img-blog.csdnimg.cn/20210609224919386.png)

- 在垃圾回收的`整理阶段`，将活动的对象往堆内存的一端移动
  ![步骤三](https://img-blog.csdnimg.cn/20210609224956168.png)

- 在垃圾回收的`清除阶段`，将活动对象左侧的内存全部回收
  ![步骤四](https://img-blog.csdnimg.cn/20210609225017285.png)

至此就完成了一次老生代垃圾回收的全部过程。

我们在前文中说过，由于 JS 的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为`全停顿(stop-the-world)`。

在`标记阶段`同样会阻碍主线程的执行，一般来说，老生代会保存大量存活的对象，如果在`标记阶段`将整个堆内存遍历一遍，那么势必会造成严重的卡顿。

因此，为了减少垃圾回收带来的停顿时间，`V8` 引擎又引入了 `Incremental Marking(增量标记)`的概念，即将原本需要一次性遍历堆内存的操作改为`增量标记`的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 `JS` 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。

这个理念其实有点像 `React` 框架中的 `Fiber` 架构，只有在浏览器的空闲时间才会去遍历 `Fiber Tree` 执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。

得益于`增量标记`的好处，`V8` 引擎后续继续引入了`延迟清理(lazy sweeping)`和`增量式整理(incremental compaction)`，让`清理`和`整理`的过程也变成`增量式`的。同时为了充分利用`多核 CPU`的性能，也将引入`并行标记`和`并行清理`，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。

## 如何减少垃圾回收

首先，最明显的，`new` 关键字就意味着一次内存分配，例如 `new Foo()`。

最好的处理方法是：**在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象**。

另外还有以下三种内存分配表达式（可能不像 new 关键字那么明显了）：

- {} （创建一个新对象）
- [] （创建一个新数组）
- function() {…} (创建一个新的方法，注意：新建方法也会导致垃圾收集！！)

### 对象 object 优化

为了最大限度的实现对象的重用，应该像避使用 `new` 语句一样避免使用 `{}` 来新建对象。

`{“foo”:”bar”}`这种方式新建的带属性的对象，常常作为方法的返回值来使用，可是这将会导致过多的内存创建，因此最好的解决办法是：**每一次函数调用完成之后，将需要返回的数据放入一个全局的对象中，并返回此全局对象**。

如果使用这种方式，就意味着每一次方法调用都会导致全局对象内容的修改，这有可能会导致错误的发生。因此，一定要对此全局对象的使用进行详细的注释和说明。

### 数组 array 优化

将`[]`赋值给一个数组对象，是清空数组的捷径（例如： `arr = [];`），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（`arr.length = 0`）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。

### 方法 function 优化

方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。

在游戏的主循环中，`setTimeout` 或 `requestAnimationFrame` 来调用一个成员方法是很常见的，例如：

```js
setTimeout(
  (function (self) {
    return function () {
      self.tick();
    };
  })(this),
  16,
);
```

每过 `16` 毫秒调用一次 `this.tick()`，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！

为了解决这个问题，可以将作为返回值的方法保存起来，例如：

```js
// at startup
this.tickFunc = (function (self) {
  return function () {
    self.tick();
  };
})(this);

// in the tick() function
setTimeout(this.tickFunc, 16);
```

相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。
