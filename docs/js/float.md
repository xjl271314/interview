---
title: 浮点数精度(IEEE754)
nav:
  title: javascript
  path: /javascript
  order: 0
group:
  title: javascript相关试题
  path: /javascript/project
---

# javaScript 中的浮点数是如何计算的?

- 2021.06.07

首先是经典的面试题:

```js
0.1 + 0.2 是否等于 0.3?
```

这个问题，大多数人都知道答案是`否`。至于为什么，也大致上知道是由于`浮点数精度计算规则(IEEE754)`计算问题导致的，那么具体内部的原理是什么呢? 我们来探究探究。

## javascript 中的 Number

在`ECMAScript`中`Number 类型`是采用`IEEE754 格式`来表示`整数`和`浮点数值`（浮点数值在某些语言中也被称为`双精度数值`）。所谓 `IEEE754 标准`，全称 `IEEE 二进制浮点数算术标准`，这个标准定义了表示浮点数的格式等内容。

在 `IEEE754` 中，规定了四种表示浮点数值的方式：`单精确度（32位）`、`双精确度（64位）`、`延伸单精确度`、`与延伸双精确度`。像 `ECMAScript` 采用的就是`双精确度`，也就是说，会用 `64` 位字节来储存一个`浮点数`。

- 1 符号位，0 表示正数，1 表示负数 s
- 11 指数位（e）
- 52 尾数，小数部分（即有效数字）

在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，然后进行`对阶运算`，JS 引擎对二进制进行截断，所以造成精度丢失。

**总结：精度丢失可能出现在`进制转换`和`对阶运算`中。**

## 浮点数转二进制

我们来瞅瞅 10 进制的计算:

```js
1020 = 1 * 10^3 + 0 * 10^2 + 2 * 10^1 + 0 * 10^0;
```

假如换成 2 进制计算:

```js
// 1111111100
1020 = 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0;
```

那如果是 0.75 用二进制表示呢？同理应该是：

```js
0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...
```

因为使用的是二进制，这里的 `abcd……`的值的要么是 `0` 要么是 `1`。

那怎么算出 `abcd……` 的值呢，我们可以两边不停的乘以 `2` 算出来，解法如下：

```js
1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3... (所以 a = 1)
```

剩下的：

```js
0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3...
// 乘以2
1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3... (所以 b = 1)
```

所以 `0.75` 用二进制表示就是 `0.ab`，也就是 `0.11`.

然而不是所有的数都像 `0.75` 这么好算，我们来算下 `0.1`：

```js
0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...

0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a = 0)
0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b = 0)
0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c = 0)
1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d = 1)
1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e = 1)
0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f = 0)
0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g = 0)
1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h = 1)
....
```

然后你就会发现，这个计算在不停的循环，所以 `0.1` 用二进制表示就是 `0.00011001100110011……`.

## 浮点数的存储

虽然 0.1 转成二进制时是一个无限循环的数，但计算机总要储存吧，我们知道 `ECMAScript` 使用 `64` 位字节来储存一个`浮点数`，那具体是怎么储存的呢？这就要说回 `IEEE754` 这个标准了，毕竟是这个标准规定了存储的方式。

这个标准认为，一个`浮点数 (Value)` 可以这样表示：

```
Value = sign * exponent * fraction
```

看起来很抽象的样子，简单理解就是`科学计数法……`,比如 `-1020`，用科学计数法表示就是:

```js
(-1 * 10) ^ (3 * 1.02);
```

`sign` 就是 `-1`，`exponent` 就是 `10^3`，`fraction` 就是 `1.02`.

对于`二进制`也是一样，以 `0.1` 的二进制 `0.00011001100110011……` 这个数来说：

```js
1 * 2^-4 * 1.1001100110011……
```

其中 `sign` 就是 `1`，`exponent` 就是 `2^-4`，`fraction` 就是 `1.1001100110011……`.

而当只做二进制科学计数法的表示时，这个 `Value` 的表示可以再具体一点变成：

```js
V = -1 ^ (S * (1 + Fraction) * 2) ^ E;
```

其中：

- `(-1)^S` 表示`符号位`，当 `S = 0`，V 为`正数`；当 `S = 1`，V 为`负数`。

- `(1 + Fraction)`，这是因为所有的浮点数都可以表示为 `1.xxxx * 2^xxx` 的形式，前面的一定是 `1.xxx`，那干脆我们就不存储这个 `1` 了，直接存后面的 `xxxxx` 好了，这也就是 `Fraction` 的部分。

- `2^E`,如果是 `1020.75`，对应二进制数就是 `1111111100.11`，对应二进制科学计数法就是 `1 * 1.11111110011 * 2^9`，`E` 的值就是 `9`，而如果是 `0.1` ，对应二进制是 `1 * 1.1001100110011…… * 2^-4`， `E` 的值就是 `-4`，也就是说，`E` 既可能是`负数`，又可能是`正数`，那问题就来了，那我们该怎么储存这个 `E` 呢？

我们这样解决，假如我们用 `8` 位字节来存储 `E` 这个数，如果只有`正数`的话，储存的值的范围是 `0 ~ 254`，而如果要储存`正负数`的话，值的范围就是 `-127~127`，我们在存储的时候，把要存储的数字加上 `127`，这样当我们存 `-127` 的时候，我们存 `0`，当存 `127` 的时候，存 `254`，这样就解决了`存负数`的问题。对应的，当取值的时候，我们再减去 `127`。

**所以呢，真到实际存储的时候，我们并不会直接存储 `E`，而是会存储 `E + bias`，当用 `8` 个字节的时候，这个 `bias` 就是 `127`。**

所以，如果要存储一个浮点数，我们存 `S` 和 `Fraction` 和 `E + bias` 这三个值就好了，那具体要分配多少个字节位来存储这些数呢？`IEEE754` 给出了标准：

![IEEE754标准](https://img-blog.csdnimg.cn/20210607170648405.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hqbDI3MTMxNA==,size_16,color_FFFFFF,t_70)

在这个标准下：

我们会用 `1` 位存储 `S`，`0` 表示正数，`1` 表示负数。

用 `11` 位存储 `E + bias`，对于 `11` 位来说，`bias` 的值是 `2^(11-1) - 1`，也就是 `1023`。

用 `52` 位存储 `Fraction`。

举个例子，就拿 `0.1` 来看，对应二进制是 `1 * 1.1001100110011…… * 2^-4`， `Sign` 是 `0`，`E + bias` 是 `-4 + 1023 = 1019`，`1019` 用二进制表示是 `1111111011`，`Fraction` 是 `1001100110011……`

对应 64 个字节位的完整表示就是：

```js
0 01111111011 1001100110011001100110011001100110011001100110011010
```

同理, 0.2 表示的完整表示是：

```js
0 01111111100 1001100110011001100110011001100110011001100110011010
```

所以当 `0.1` 存下来的时候，就已经发生了精度丢失，当我们用`浮点数`进行运算的时候，使用的其实是`精度丢失后的数`。

## 浮点数的运算

关于浮点数的运算，一般由以下五个步骤完成：

1. 对阶
2. 尾数运算
3. 规格化
4. 舍入处理
5. 溢出判断。

我们来简单看一下 `0.1` 和 `0.2` 的计算。

### 对阶

> 所谓对阶，就是把阶码调整为相同，比如 `0.1` 是 `1.1001100110011…… * 2^-4`，阶码是 `-4`，而 `0.2` 就是 `1.10011001100110...* 2^-3`，阶码是 `-3`，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是`小阶对大阶`，也就是 `0.1` 的 `-4` 调整为 `-3`，对应变成 `0.11001100110011…… * 2^-3`.

### 尾数运算

```js
  0.1100110011001100110011001100110011001100110011001101
+ 1.1001100110011001100110011001100110011001100110011010
————————————————————————————————————————————————————————
 10.0110011001100110011001100110011001100110011001100111
// 结果为 10.0110011001100110011001100110011001100110011001100111 * 2^-3
```

### 规格化

将这个结果规格化，变成 `1.0011001100110011001100110011001100110011001100110011(1) * 2^-2`

括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。

### 舍入处理

四舍五入对应到二进制中，就是 `0` 舍 `1` 入，因为我们要把括号里的 `1` 丢了，所以这里会进一，结果变成:

```js
(1.00110011001100110011001100110011001100110011001101 * 2) ^ -2;
```

### 溢出判断

略...

所以最终的结果存成 64 位就是:

```js
0 01111111101 0011001100110011001100110011001100110011001100110100
```

将它转换为`10`进制数就得到 `0.30000000000000004440892098500626`.

因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 `0.1 + 0.2 !== 0.3`.

## 十进制转二进制

#### 1. `正整数转化`: 不断除以 2 余数从下往上读

```js
// 42 转 2进制
42 / 2 = 21 -------0 （低位）
21 / 2 = 10 -------1
10 / 2 = 5  -------0
5  / 2 = 2  -------1
2  / 2 = 1  -------0 （高位）
1  / 2 = 0  -------1
// 101010 补齐 0010 1010
// 1个字节是：8位 int类型，4个字节，那么就应该是32位
```

#### 2. `负整数转二进制`: 先不管符号直接获得二进制，然后取反，再 + 1

```js
42 转 2进制 0010 1010
取反之后 1101 0101
再 + 1 1101 0110
```

#### 3. `小数转二进制`: 整数部分依旧遵循上述转换方法，小数部分不断 \* 2 取整就是了（反正不是 1 就是 0）

```js
// 42.125 42转二进制后是：0010 1010 0.125 转2进制
0.125 x 2 = 0.25 -----0
0.25  x 2 = 0.5  -----0
0.5   x 2 = 1.0  -----1
0.125 就该是 0.001
// 0010 1010.0010 0000
```

#### 4. `整数二进制转换为十进制`: 如何区分一个二进制是正数，还是负数，非常简单，看补齐后的首位是 0 或者 1，0 就是整数，1 就是负数，然后再每位，乘于 2^n ，分别相加就可以了

```js
// 101010 先补齐 0010 1010 得到是整数 逐位相乘相加
0 * 2^0 = 0
1 * 2^1 = 2
0 * 2^2 = 0
1 * 2^3 = 8
0 * 2^4 = 0
1 * 2^5 = 32
// 0 + 2 + 0 + 8 + 0 + 32 = 42
```

#### 5. `负整数二进制转换为十进制`: 首位是 1，说明这是 1 个负整数，应该先-1，并且取反，再每位，乘于 2^n ，分别相加后取负数就可以了

```js
// 1101 0110 - 1 = 1101 0101 取反 0010 1010
0 * 2^0 = 0
1 * 2^1 = 2
0 * 2^2 = 0
1 * 2^3 = 8
0 * 2^4 = 0
1 * 2^5 = 32
// 0 + 2 + 0 + 8 + 0 + 32 = 42 再加上 负号 = -42
```

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Info } from 'interview';

const txt =
  '`二进制`的减法，与`十进制`的减法一致，不够就去高位借，只不过`十进制`中，借的1位相当于10，在`二进制`中，借的1位相当于2。';

export default () => <Info type="info" txt={txt} />;
```

#### 6. `小数二进制转十进制`: 0010 1010.0010 0000 转 10 进制

```js
// 小数点之前是：42
0 * 2^0 = 0
1 * 2^1 = 2
0 * 2^2 = 0
1 * 2^3 = 8
0 * 2^4 = 0
1 * 2^5 = 32
// 小数点之后是：0.125
0 * 2^-1 = 0
0 * 2^-2 = 0
1 * 2^-3 = 0.125
// 相加后是42.125
```

## 全进制转换方法

```js
parseInt(num, 8); //八进制转十进制
parseInt(num, 16); //十六进制转十进制
parseInt(num).toString(8); //十进制转八进制
parseInt(num).toString(16); //十进制转十六进制
parseInt(num, 2).toString(8); //二进制转八进制
parseInt(num, 2).toString(16); //二进制转十六进制
parseInt(num, 8).toString(2); //八进制转二进制
parseInt(num, 8).toString(16); //八进制转十六进制
parseInt(num, 16).toString(2); //十六进制转二进制
parseInt(num, 16).toString(8); //十六进制转八进制
```
