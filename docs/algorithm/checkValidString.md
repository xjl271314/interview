---
title: 有效的括号字符串
nav:
  title: 编程题
  path: /writing
group:
  title: 中等
  path: /writing/project/middle
  order: 2
---

# LeetCode 678：有效的括号字符串

- 2022.03.28

[有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/)给定一个只包含三种字符的字符串：`（`，`）` 和 `*`，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

1. 任何左括号 `(`  必须有相应的右括号 `)`。
2. 任何右括号 `)`  必须有相应的左括号 `(` 。
3. 左括号 `(` 必须在对应的右括号之前 `)`。
4. `*`  可以被视为单个右括号 `)` ，或单个左括号 `(`，或一个空字符串。
5. 一个空字符串也被视为有效字符串。

- 示例 1：

  ```js
  输入: '()';
  输出: True;
  ```

- 示例 2：

  ```js
  输入: '(*)';
  输出: True;
  ```

- 示例 3：

  ```js
  输入: '(*))';
  输出: True;
  ```

- 提示：
  - 字符串大小将在 [1，100] 范围内。

## 动态规划

要判断 `s` 是否为有效的括号字符串，需要判断 `s` 的首尾字符以及 `s` 的中间字符是否符合有效的括号字符串的要求。可以使用动态规划求解。

假设字符串 `s` 的长度为 `n`。定义 `dp[i][j]` 表示字符串 `s` 从下标 `i` 到 `j` 的子串是否为有效的括号字符串，其中 `0≤i≤j<n`。

动态规划的边界情况是子串的长度为 `1` 或 `2` 的情况。

- 当子串的长度为 `1` 时，只有当该字符是 `*` 时，才是有效的括号字符串，此时子串可以看成空字符串；

- 当子串的长度为 `2` 时，只有当两个字符是 `()`, `(*`, `*)`, `**` 中的一种情况时，才是有效的括号字符串，此时子串可以看成 `()`。

当子串的长度大于 2 时，需要根据子串的首尾字符以及中间的字符判断子串是否为有效的括号字符串。字符串 s 从下标 `i` 到 `j` 的子串的长度大于 `2` 等价于 `j−i≥2`，此时 `dp[i][j]` 的计算如下，只要满足以下一个条件就有 `dp[i][j]=true`：

- 如果 `s[i]` 和 `s[j]` 分别为左括号和右括号，或者为 `*`，则当 `dp[i+1][j−1]=true` 时，`dp[i][j]=true`，此时 `s[i]` 和 `s[j]` 可以分别看成左括号和右括号；

- 如果存在 `i≤k<j` 使得 `dp[i][k]` 和 `dp[k+1][j]` 都为 `true`，则 `dp[i][j]=true`，因为字符串 s 的下标范围 `[i,k]` 和 `[k+1,j]` 的子串分别为有效的括号字符串，将两个子串拼接之后的子串也为有效的括号字符串，对应下标范围 `[i,j]`。

上述计算过程为从较短的子串的结果得到较长的子串的结果，因此需要注意动态规划的计算顺序。最终答案为 `dp[0][n−1]`。

### javascript

- 执行用时：96 ms, 在所有 JavaScript 提交中击败了 5.18% 的用户
- 内存消耗：43.7 MB, 在所有 JavaScript 提交中击败了 5.18% 的用户

```js
/**
 * @param {string} s
 * @return {boolean}
 * 时间复杂度：O(n^3)，其中 n 是字符串 s 的长度。动态规划的状态数是 O(n^2)，每个状态的计算时间最多为 O(n)。
 * 空间复杂度：O(n^2)，其中 n 是字符串 s 的长度。创建了 n 行 n 列的二维数组 dp。
 */
var checkValidString = function (s) {
  const len = s.length;
  const dp = new Array(len).fill(0).map(() => new Array(len).fill(false));
  for (let i = 0; i < len; i++) {
    if (s[i] === '*') {
      dp[i][i] = true;
    }
  }
  for (let i = 1; i < len; i++) {
    const c1 = s[i - 1],
      c2 = s[i];
    dp[i - 1][i] = (c1 === '(' || c1 === '*') && (c2 === ')' || c2 === '*');
  }

  for (let i = len - 3; i >= 0; i--) {
    const c1 = s[i];
    for (let j = i + 2; j < len; j++) {
      const c2 = s[j];
      if ((c1 === '(' || c1 === '*') && (c2 === ')' || c2 === '*')) {
        dp[i][j] = dp[i + 1][j - 1];
      }
      for (let k = i; k < j && !dp[i][j]; k++) {
        dp[i][j] = dp[i][k] && dp[k + 1][j];
      }
    }
  }
  return dp[0][len - 1];
};
```

## 栈

括号匹配的问题可以用栈求解。

如果字符串中没有`星号`，则只需要一个栈存储`左括号`，在`从左到右`遍历字符串的过程中检查括号是否匹配。

在有星号的情况下，需要两个栈分别存储`左括号`和`星号`。从左到右遍历字符串，进行如下操作。

- 如果遇到`左括号`，则将当前下标存入`左括号栈`。
- 如果遇到`星号`，则将当前下标存入`星号栈`。
- 如果遇到`右括号`，则需要有一个`左括号`或`星号`和`右括号`匹配，由于`星号`也可以看成`右括号`或者空字符串，因此当前的`右括号`应优先和`左括号`匹配，没有`左括号`时和`星号`匹配：
  - 如果`左括号栈`不为空，则从`左括号栈`弹出栈顶元素；
  - 如果`左括号栈`为空且`星号栈`不为空，则从`星号栈`弹出栈顶元素；
  - 如果`左括号栈`和`星号栈`都为空，则没有字符可以和当前的`右括号`匹配，返回 false。

遍历结束之后，`左括号栈`和`星号栈`可能还有元素。为了将每个`左括号`匹配，需要将`星号`看成`右括号`，且每个`左括号`必须出现在其匹配的`星号`之前。

当两个栈都不为空时，每次从`左括号栈`和`星号栈`分别弹出栈顶元素，对应`左括号下标`和`星号下标`，判断是否可以匹配，匹配的条件是`左括号下标小于星号下标`，如果`左括号下标大于星号下标`则返回 `false`。

最终判断`左括号栈`是否为空。

- 如果`左括号栈`为空，则`左括号`全部匹配完毕，剩下的`星号`都可以看成空字符串，此时 `s` 是有效的括号字符串，返回 `true`。
- 如果`左括号栈`不为空，则还有`左括号`无法匹配，此时 `s` 不是有效的括号字符串，返回 `false`。

### javascript

- 执行用时：56 ms, 在所有 JavaScript 提交中击败了 90.93% 的用户
- 内存消耗：41.2 MB, 在所有 JavaScript 提交中击败了 14.25% 的用户

```js
/**
 * @param {string} s
 * @return {boolean}
 * 时间复杂度：O(n)，其中 n 是字符串 s 的长度。需要遍历字符串一次，遍历过程中每个字符的操作时间都是 O(1)，遍历结束之后对左括号栈和星号栈弹出元素的操作次数不会超过 n。
 * 空间复杂度：O(n)，其中 n 是字符串 s 的长度。空间复杂度主要取决于左括号栈和星号栈，两个栈的元素总数不会超过 n。
 */
var checkValidString = function (s) {
  const len = s.length;
  const left = [],
    stars = [];
  // 变量字符串 构造左括号栈 和 星号栈
  for (let i = 0; i < len; i++) {
    if (s[i] == '(') {
      left.push(i);
    } else if (s[i] == '*') {
      stars.push(i);
    } else {
      // 优先匹配左括号
      if (left.length) {
        left.pop();
      } else if (stars.length) {
        stars.pop();
      } else {
        return false;
      }
    }
  }

  // 当左括号栈和星号栈不为空的时候 不断出栈
  while (left.length && stars.length) {
    const leftIndex = left.pop();
    const starIndex = stars.pop();
    if (leftIndex > starIndex) {
      return false;
    }
  }

  return left.length === 0;
};
```

## 贪心

使用贪心的思想，可以将空间复杂度降到 O(1)。

从左到右遍历字符串，遍历过程中，未匹配的`左括号`数量可能会出现如下变化：

- 如果遇到`左括号`，则未匹配的左括号数量加 1；
- 如果遇到`右括号`，则需要有一个`左括号`和`右括号`匹配，因此未匹配的`左括号`数量减 1；
- 如果遇到`星号`，由于`星号`可以看成`左括号`、`右括号`或空字符串，因此未匹配的`左括号`数量可能加 1、减 1 或不变。

基于上述结论，可以在遍历过程中维护未匹配的左括号数量可能的最小值和最大值，根据遍历到的字符更新最小值和最大值：

- 如果遇到左括号，则将`最小值`和`最大值`分别加 1；
- 如果遇到右括号，则将`最小值`和`最大值`分别减 1；
- 如果遇到星号，则将`最小值`减 1，将`最大值`加 1。

任何情况下，未匹配的左括号数量必须非负，因此当最大值变成负数时，说明没有左括号可以和右括号匹配，返回 `false`。

当最小值为 0 时，不应将最小值继续减少，以确保最小值非负。

遍历结束时，所有的左括号都应和右括号匹配，因此只有当最小值为 0 时，字符串 s 才是有效的括号字符串。

### javascript

- 执行用时：56 ms, 在所有 JavaScript 提交中击败了 91.03% 的用户
- 内存消耗：41.3 MB, 在所有 JavaScript 提交中击败了 9.82% 的用户

```js
/**
 * @param {string} s
 * @return {boolean}
 * 时间复杂度：O(n)，其中 n 是字符串 s 的长度。需要遍历字符串一次，遍历过程中每个字符的操作时间都是 O(1)，遍历结束之后对左括号栈和星号栈弹出元素的操作次数不会超过 n。
 * 空间复杂度：O(1)
 */
var checkValidString = function (s) {
  const len = s.length;
  let minCount = 0,
    maxCount = 0;
  for (let i = 0; i < len; i++) {
    if (s[i] == '(') {
      minCount++;
      maxCount++;
    } else if (s[i] == ')') {
      minCount = Math.max(minCount - 1, 0);
      maxCount--;
      if (maxCount < 0) {
        return false;
      }
    } else {
      minCount = Math.max(minCount - 1, 0);
      maxCount++;
    }
  }

  return minCount === 0;
};
```
