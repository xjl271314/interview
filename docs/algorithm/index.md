---
title: 算法基础
nav:
  title: 编程题
  path: /writing
group:
  title: 算法基础
  path: /writing/project/base
  order: 0
---

# 算法基础

> 算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。

我们主要是从算法所占用的`「时间」`和 `「空间」` 两个维度去考量不同算法之间的优劣。

- 时间维度：是指执行当前算法所消耗的时间，我们通常用`「时间复杂度」`来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用`「空间复杂度」`来描述。

## 时间复杂度

> 「 大 O 符号表示法 」，即 T(n) = O(f(n))

我们先来看个例子：

```js
for (i = 1; i <= n; ++i) {
  j = i;
  j++;
}
```

通过「 大 O 符号表示法 」，这段代码的时间复杂度为：`O(n)` ，为什么呢?

在`大O符号表示法`中，时间复杂度的公式是： `T(n) = O( f(n) )`，其中`f(n)` 表示**每行代码执行次数之和**，而 `O` 表示正比例关系，这个公式的全称是：`算法的渐进时间复杂度`。

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 `1颗粒时间` 来表示，那么这个例子的第一行耗时是`1个颗粒时间`，第三行的执行时间是 `n个颗粒时间`，第四行的执行时间也是 `n个颗粒时间`（第二行和第五行是符号，暂时忽略），那么总时间就是 `1颗粒时间 + n颗粒时间 + n颗粒时间` ，即 `(1+2n)个颗粒时间`，即： `T(n) = (1+2n)*颗粒时间`，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：`T(n) = O(n)`

为什么可以这么去简化呢，因为大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

所以上面的例子中，如果 n 无限大的时候，`T(n) = time(1+2n)`中的常量 1 就没有意义了，倍数 2 也意义不大。因此直接简化为`T(n) = O(n)` 就可以了。

### 常见的时间复杂度量级

- 常数阶 O(1)

  > 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是`O(1)`，如：

  ```js
  int i = 1;
  int j = 2;
  ++i;
  j++;
  int m = i + j;
  ```

  上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用`O(1)`来表示它的时间复杂度。

- 对数阶 O(logN)

  ```js
  int i = 1;

  while(i<n)
  {
      i = i * 2;
  }
  ```

  从上面代码可以看到，在`while`循环里面，每次都将 `i` 乘以 `2`，乘完之后，`i` 距离 `n` 就越来越近了。

  我们试着求解一下，假设循环`x`次之后，`i` 就大于 `2` 了，此时这个循环就退出了，也就是说 `2` 的 `x` 次方等于 `n`，那么 `x = log2^n`也就是说当循环 `log2^n` 次以后，这个代码就结束了。因此这个代码的时间复杂度为：`O(logn)`。

- 线性阶 O(n)

  这个在最开始的代码示例中就讲解过了，如：

  ```js
  for (i = 1; i <= n; ++i) {
    j = i;
    j++;
  }
  ```

  这段代码，`for`循环里面的代码会执行`n`遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用`O(n)`来表示它的时间复杂度。

- 线性对数阶 O(nlogN)

  线性对数阶`O(nlogN)` 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 `n * O(logN)`，也就是了`O(nlogN)`。

  ```js
  for (m = 1; m < n; m++) {
    i = 1;
    while (i < n) {
      i = i * 2;
    }
  }
  ```

- 平方阶 O(n²)

  如果把 `O(n)` 的代码再嵌套循环一遍，它的时间复杂度就是 `O(n²)` 了。

  ```js
  for (x = 1; i <= n; x++) {
    for (i = 1; i <= n; i++) {
      j = i;
      j++;
    }
  }
  ```

  如果将其中一层循环的 n 改成 m，即：

  ```js
  for (x = 1; i <= m; x++) {
    for (i = 1; i <= n; i++) {
      j = i;
      j++;
    }
  }
  ```

  那它的时间复杂度就变成了 `O(m*n)`。

- 立方阶 O(n³)
- K 次方阶 O(n^k)
- 指数阶(2^n)

从上至下依次的时间复杂度越来越大，执行的效率越来越低。

## 空间复杂度

`空间复杂度`是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 `S(n)` 来定义。

空间复杂度比较常用的有：`O(1)`、`O(n)`、`O(n²)`，我们下面来看看：

- 空间复杂度 O(1)

如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 `O(1)`

```js
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 `i、j、m` 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 `S(n) = O(1)`

- 空间复杂度 O(n)

```js
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 `S(n) = O(n)`

## 哈希表

- 2022.01.27

> 哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。

`哈希表`通常是基于`数组`实现的，但是相对于`数组`，它存在更多优势：

- 哈希表可以提供非常快速的 `插入-删除-查找` 操作。
- 无论多少数据，插入和删除值都只需接近常量的时间，即 `O(1)` 的时间复杂度。实际上，只需要几个机器指令即可完成。
- 哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。
- 哈希表相对于树来说编码要简单得多。

哈希表同样存在不足之处：

- 哈希表中的数据是`无序`的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。
- 通常情况下，哈希表中的 `key` 是不允许重复的，不能放置相同的 `key`，用于保存不同的元素。

哈希表是什么？

- 哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。
- 哈希表的结构就是`数组`，但它神奇之处在于对下标值的一种变换，这种变换我们可以称之为`哈希函数`，通过哈希函数可以获取 `HashCode`。

通过以下案例了解哈希表：

- 案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。

- 案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。

**也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。**

### 哈希化

> 将大数字转化成数组范围内下标的过程，称之为哈希化。

### 哈希函数

> 我们通常会将单词转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数。

### 哈希表

> 对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。

在实际中，经过哈希函数哈希化过后得到的下标值可能有重复，这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。

解决冲突常见的两种方案：`链地址法（拉链法）`和`开放地址法`。
