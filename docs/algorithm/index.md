---
title: 算法基础
nav:
  title: 编程题
  path: /writing
group:
  title: 算法基础
  path: /writing/project/base
  order: 0
---

# 算法基础

> 算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。

我们主要是从算法所占用的`「时间」`和 `「空间」` 两个维度去考量不同算法之间的优劣。

- 时间维度：是指执行当前算法所消耗的时间，我们通常用`「时间复杂度」`来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用`「空间复杂度」`来描述。

## 时间复杂度

> 「 大 O 符号表示法 」，即 T(n) = O(f(n))

我们先来看个例子：

```js
for (i = 1; i <= n; ++i) {
  j = i;
  j++;
}
```

通过「 大 O 符号表示法 」，这段代码的时间复杂度为：`O(n)` ，为什么呢?

在`大O符号表示法`中，时间复杂度的公式是： `T(n) = O( f(n) )`，其中`f(n)` 表示**每行代码执行次数之和**，而 `O` 表示正比例关系，这个公式的全称是：`算法的渐进时间复杂度`。

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 `1颗粒时间` 来表示，那么这个例子的第一行耗时是`1个颗粒时间`，第三行的执行时间是 `n个颗粒时间`，第四行的执行时间也是 `n个颗粒时间`（第二行和第五行是符号，暂时忽略），那么总时间就是 `1颗粒时间 + n颗粒时间 + n颗粒时间` ，即 `(1+2n)个颗粒时间`，即： `T(n) = (1+2n)*颗粒时间`，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：`T(n) = O(n)`

为什么可以这么去简化呢，因为大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

所以上面的例子中，如果 n 无限大的时候，`T(n) = time(1+2n)`中的常量 1 就没有意义了，倍数 2 也意义不大。因此直接简化为`T(n) = O(n)` 就可以了。

### 常见的时间复杂度量级

- 常数阶 O(1)

  > 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是`O(1)`，如：

  ```js
  int i = 1;
  int j = 2;
  ++i;
  j++;
  int m = i + j;
  ```

  上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用`O(1)`来表示它的时间复杂度。

- 对数阶 O(logN)

  ```js
  int i = 1;

  while(i<n)
  {
      i = i * 2;
  }
  ```

  从上面代码可以看到，在`while`循环里面，每次都将 `i` 乘以 `2`，乘完之后，`i` 距离 `n` 就越来越近了。

  我们试着求解一下，假设循环`x`次之后，`i` 就大于 `2` 了，此时这个循环就退出了，也就是说 `2` 的 `x` 次方等于 `n`，那么 `x = log2^n`也就是说当循环 `log2^n` 次以后，这个代码就结束了。因此这个代码的时间复杂度为：`O(logn)`。

- 线性阶 O(n)

  这个在最开始的代码示例中就讲解过了，如：

  ```js
  for (i = 1; i <= n; ++i) {
    j = i;
    j++;
  }
  ```

  这段代码，`for`循环里面的代码会执行`n`遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用`O(n)`来表示它的时间复杂度。

- 线性对数阶 O(nlogN)

  线性对数阶`O(nlogN)` 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 `n * O(logN)`，也就是了`O(nlogN)`。

  ```js
  for (m = 1; m < n; m++) {
    i = 1;
    while (i < n) {
      i = i * 2;
    }
  }
  ```

- 平方阶 O(n²)

  如果把 `O(n)` 的代码再嵌套循环一遍，它的时间复杂度就是 `O(n²)` 了。

  ```js
  for (x = 1; i <= n; x++) {
    for (i = 1; i <= n; i++) {
      j = i;
      j++;
    }
  }
  ```

  如果将其中一层循环的 n 改成 m，即：

  ```js
  for (x = 1; i <= m; x++) {
    for (i = 1; i <= n; i++) {
      j = i;
      j++;
    }
  }
  ```

  那它的时间复杂度就变成了 `O(m*n)`。

- 立方阶 O(n³)
- K 次方阶 O(n^k)
- 指数阶(2^n)

从上至下依次的时间复杂度越来越大，执行的效率越来越低。

## 空间复杂度

`空间复杂度`是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 `S(n)` 来定义。

空间复杂度比较常用的有：`O(1)`、`O(n)`、`O(n²)`，我们下面来看看：

- 空间复杂度 O(1)

如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 `O(1)`

```js
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 `i、j、m` 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 `S(n) = O(1)`

- 空间复杂度 O(n)

```js
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 `S(n) = O(n)`
